diff --git a/Cargo.lock b/Cargo.lock
index 8657570..f7ede94 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1,26 +1,3 @@
-[root]
-name = "rpc-perf"
-version = "2.1.0-pre"
-dependencies = [
- "byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "bytes 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "crc 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "log-panics 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "mio 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)",
- "mpmc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "pad 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "rand 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)",
- "ratelimit 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "shuteye 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "simple_logger 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "slab 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "tic 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
- "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
- "toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
-]
-
 [[package]]
 name = "adler32"
 version = "1.0.2"
@@ -28,16 +5,24 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "allan"
-version = "0.2.2"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "arrayvec"
+version = "0.3.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "odds 0.2.26 (registry+https://github.com/rust-lang/crates.io-index)",
+]
 
 [[package]]
 name = "arrayvec"
-version = "0.3.23"
+version = "0.4.7"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "nodrop 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
- "odds 0.2.25 (registry+https://github.com/rust-lang/crates.io-index)",
+ "nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -50,9 +35,14 @@ name = "bitflags"
 version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "bitflags"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "build_const"
-version = "0.2.0"
+version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -70,9 +60,18 @@ name = "bytes"
 version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "bytes"
+version = "0.4.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "cfg-if"
-version = "0.1.2"
+version = "0.1.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -80,7 +79,7 @@ name = "chrono"
 version = "0.2.25"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "num 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
  "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -91,18 +90,19 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "clocksource"
-version = "0.2.2"
+version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
-name = "conv"
-version = "0.3.3"
+name = "cookie"
+version = "0.2.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "custom_derive 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
+ "url 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -110,23 +110,48 @@ name = "crc"
 version = "1.5.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "build_const 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "crc-core 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "build_const 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crc-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "crc-core"
-version = "0.1.0"
+version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
-name = "custom_derive"
-version = "0.1.7"
+name = "crossbeam-deque"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-epoch 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-utils 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "crossbeam-epoch"
+version = "0.4.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cfg-if 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crossbeam-utils 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "crossbeam-utils"
+version = "0.3.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
 
 [[package]]
 name = "deflate"
-version = "0.7.17"
+version = "0.7.18"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "adler32 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -192,7 +217,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "fnv"
-version = "1.0.5"
+version = "1.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -203,6 +228,15 @@ dependencies = [
  "fuchsia-zircon-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "fuchsia-zircon"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bitflags 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "fuchsia-zircon-sys"
 version = "0.2.0"
@@ -211,30 +245,147 @@ dependencies = [
  "bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "fuchsia-zircon-sys"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "futures"
+version = "0.1.21"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "futures-cpupool"
+version = "0.1.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "getopts"
 version = "0.2.15"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "h2"
+version = "0.1.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bytes 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "http 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "indexmap 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "string 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "heatmap"
-version = "0.6.5"
+version = "0.6.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "histogram 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "histogram 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)",
  "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "histogram"
-version = "0.6.7"
+version = "0.6.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "hpack"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "hsl"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "http"
+version = "0.1.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "httparse"
+version = "1.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "hyper"
+version = "0.9.18"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cookie 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "httparse 1.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "language-tags 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mime 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
+ "solicit 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
+ "traitobject 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "typeable 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicase 1.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "url 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "hyper"
+version = "0.12.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures-cpupool 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "h2 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "http 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "httparse 1.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "net2 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
+ "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-tcp 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-timer 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "want 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "idna"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "indexmap"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "inflate"
 version = "0.2.0"
@@ -242,10 +393,10 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "iovec"
-version = "0.1.1"
+version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
  "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -259,43 +410,52 @@ dependencies = [
 ]
 
 [[package]]
-name = "lazycell"
-version = "0.5.1"
+name = "language-tags"
+version = "0.2.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
-name = "libc"
-version = "0.2.32"
+name = "lazy_static"
+version = "0.2.11"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
-name = "log"
-version = "0.3.8"
+name = "lazy_static"
+version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
-name = "log-panics"
-version = "1.1.0"
+name = "lazycell"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "libc"
+version = "0.2.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "log"
+version = "0.3.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
-name = "magenta"
-version = "0.1.1"
+name = "log"
+version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "conv 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
- "magenta-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cfg-if 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
-name = "magenta-sys"
-version = "0.1.1"
+name = "log-panics"
+version = "1.1.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -303,21 +463,34 @@ name = "matches"
 version = "0.1.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "memoffset"
+version = "0.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "mime"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "mio"
-version = "0.6.10"
+version = "0.6.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "iovec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "lazycell 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "magenta-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazycell 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "net2 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)",
- "slab 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "net2 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -327,7 +500,7 @@ version = "0.2.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "net2 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)",
+ "net2 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
  "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
@@ -339,59 +512,62 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
 name = "net2"
-version = "0.2.31"
+version = "0.2.32"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
- "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cfg-if 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "nodrop"
-version = "0.1.9"
+version = "0.1.12"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-dependencies = [
- "odds 0.2.25 (registry+https://github.com/rust-lang/crates.io-index)",
-]
 
 [[package]]
 name = "num"
-version = "0.1.40"
+version = "0.1.42"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "num-integer 0.1.35 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-iter 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-integer 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-iter 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-traits 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "num-integer"
-version = "0.1.35"
+version = "0.1.38"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-traits 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "num-iter"
-version = "0.1.34"
+version = "0.1.37"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "num-integer 0.1.35 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-integer 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-traits 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "num-traits"
-version = "0.1.40"
+version = "0.2.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "num_cpus"
+version = "1.8.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "odds"
-version = "0.2.25"
+version = "0.2.26"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -399,39 +575,107 @@ name = "pad"
 version = "0.1.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "percent-encoding"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "png"
 version = "0.7.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "deflate 0.7.17 (registry+https://github.com/rust-lang/crates.io-index)",
+ "deflate 0.7.18 (registry+https://github.com/rust-lang/crates.io-index)",
  "inflate 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
- "num-iter 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-iter 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "prometheus"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "hyper 0.9.18 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "protobuf 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quick-error 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "spin 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "protobuf"
+version = "2.0.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "quick-error"
+version = "0.2.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "rand"
 version = "0.3.17"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "fuchsia-zircon 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
-name = "ratelimit"
+name = "rand"
 version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "ratelimit"
+version = "0.4.4-pre"
 
 [[package]]
 name = "redox_syscall"
-version = "0.1.31"
+version = "0.1.40"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "rpc-perf"
+version = "2.1.0-pre"
+dependencies = [
+ "byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bytes 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "crc 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)",
+ "histogram 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "hyper 0.12.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log-panics 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mpmc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "pad 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "prometheus 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)",
+ "ratelimit 0.4.4-pre",
+ "shuteye 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "simple_logger 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tic 0.2.4",
+ "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
+ "toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "rustc-serialize"
 version = "0.3.24"
@@ -442,13 +686,18 @@ name = "rusttype"
 version = "0.1.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "arrayvec 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)",
+ "arrayvec 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)",
  "stb_truetype 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "scopeguard"
+version = "0.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "serde"
-version = "1.0.15"
+version = "1.0.66"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -456,7 +705,7 @@ name = "shuteye"
 version = "0.3.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -464,7 +713,7 @@ name = "simple_logger"
 version = "0.4.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
  "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
@@ -473,6 +722,25 @@ name = "slab"
 version = "0.3.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "slab"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "solicit"
+version = "0.4.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "hpack 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "spin"
+version = "0.4.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "stb_truetype"
 version = "0.1.2"
@@ -481,23 +749,27 @@ dependencies = [
  "byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "string"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "tic"
 version = "0.2.4"
-source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "allan 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "clocksource 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "fnv 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "allan 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "clocksource 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)",
- "heatmap 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
- "histogram 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "mio 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)",
+ "heatmap 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "histogram 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)",
  "mpmc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)",
- "tiny_http 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "waterfall 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tiny_http 0.5.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "waterfall 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
@@ -506,36 +778,188 @@ version = "0.1.38"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)",
- "libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)",
- "redox_syscall 0.1.31 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)",
  "winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "tiny_http"
-version = "0.5.8"
+version = "0.5.9"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
  "ascii 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "chrono 0.2.25 (registry+https://github.com/rust-lang/crates.io-index)",
  "chunked_transfer 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "encoding 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)",
- "log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
- "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)",
  "url 0.2.38 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "tokio"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-fs 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-tcp 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-threadpool 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-timer 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-udp 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-codec"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-executor"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-fs"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-threadpool 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-io"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-reactor"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "slab 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-tcp"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-threadpool"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "crossbeam-deque 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-timer"
+version = "0.2.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-executor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "tokio-udp"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bytes 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mio 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-codec 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "tokio-reactor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "toml"
 version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde 1.0.66 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "traitobject"
+version = "0.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "try-lock"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "typeable"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "unicase"
+version = "1.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "version_check 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "unicode-bidi"
+version = "0.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "unicode-normalization"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "unicode-width"
-version = "0.1.4"
+version = "0.1.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
 [[package]]
@@ -548,6 +972,16 @@ dependencies = [
  "uuid 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "url"
+version = "1.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "idna 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "uuid"
 version = "0.1.18"
@@ -557,12 +991,27 @@ dependencies = [
  "rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
+[[package]]
+name = "version_check"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "want"
+version = "0.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "try-lock 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "waterfall"
-version = "0.7.0"
+version = "0.7.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 dependencies = [
- "heatmap 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "heatmap 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)",
  "hsl 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "png 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "rusttype 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
@@ -573,11 +1022,30 @@ name = "winapi"
 version = "0.2.8"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "winapi"
+version = "0.3.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
 [[package]]
 name = "winapi-build"
 version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
 [[package]]
 name = "ws2_32-sys"
 version = "0.2.1"
@@ -589,23 +1057,28 @@ dependencies = [
 
 [metadata]
 "checksum adler32 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "6cbd0b9af8587c72beadc9f72d35b9fbb070982c9e6203e46e93f10df25f8f45"
-"checksum allan 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "0781eb79c8595349e5efe3dba454d2a008323cb173a3bdd5f36f21c7f3d97b19"
-"checksum arrayvec 0.3.23 (registry+https://github.com/rust-lang/crates.io-index)" = "699e63a93b79d717e8c3b5eb1b28b7780d0d6d9e59a72eb769291c83b0c8dc67"
+"checksum allan 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)" = "62ed9db31078b3c9e56ce77857fa21f6bdb062988c24a5c989c3f44fa1317b47"
+"checksum arrayvec 0.3.25 (registry+https://github.com/rust-lang/crates.io-index)" = "06f59fe10306bb78facd90d28c2038ad23ffaaefa85bac43c8a434cde383334f"
+"checksum arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)" = "a1e964f9e24d588183fcb43503abda40d288c8657dfc27311516ce2f05675aef"
 "checksum ascii 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "3ae7d751998c189c1d4468cf0a39bb2eae052a9c58d50ebb3b9591ee3813ad50"
 "checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d"
-"checksum build_const 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "e90dc84f5e62d2ebe7676b83c22d33b6db8bd27340fb6ffbff0a364efa0cb9c9"
+"checksum bitflags 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "d0c54bb8f454c567f21197eefcdbf5679d0bd99f2ddbe52e84c77061952e6789"
+"checksum build_const 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "39092a32794787acd8525ee150305ff051b0aa6cc2abaf193924f5ab05425f39"
 "checksum byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "96c8b41881888cc08af32d47ac4edd52bc7fa27fef774be47a92443756451304"
 "checksum byteorder 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ff81738b726f5d099632ceaffe7fb65b90212e8dce59d518729e7e8634032d3d"
 "checksum bytes 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "c129aff112dcc562970abb69e2508b40850dd24c274761bb50fb8a0067ba6c27"
-"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de"
+"checksum bytes 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)" = "7dd32989a66957d3f0cba6588f15d4281a733f4e9ffc43fcd2385f57d3bf99ff"
+"checksum cfg-if 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "405216fd8fe65f718daa7102ea808a946b6ce40c742998fbfd3463645552de18"
 "checksum chrono 0.2.25 (registry+https://github.com/rust-lang/crates.io-index)" = "9213f7cd7c27e95c2b57c49f0e69b1ea65b27138da84a170133fd21b07659c00"
 "checksum chunked_transfer 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "498d20a7aaf62625b9bf26e637cf7736417cde1d0c99f1d04d1170229a85cf87"
-"checksum clocksource 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "77b31e7b79cafabc322f19df8c21674955e0a4444caf75693e50788ebc6de8f2"
-"checksum conv 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "78ff10625fd0ac447827aa30ea8b861fead473bb60aeb73af6c1c58caf0d1299"
+"checksum clocksource 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)" = "ffcfe846ac61510fe67bf890f503a883f4b0e141aee37d6904a4e53401110a11"
+"checksum cookie 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)" = "0e3d6405328b6edb412158b3b7710e2634e23f3614b9bb1c412df7952489a626"
 "checksum crc 1.5.0 (registry+https://github.com/rust-lang/crates.io-index)" = "fba69ea0e15e720f7e1cfe1cf3bc55007fbd41e32b8ae11cfa343e7e5961e79a"
-"checksum crc-core 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "003d1170779d405378223470f5864b41b79a91969be1260e4de7b4ec069af69c"
-"checksum custom_derive 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "ef8ae57c4978a2acd8b869ce6b9ca1dfe817bff704c220209fdef2c0b75a01b9"
-"checksum deflate 0.7.17 (registry+https://github.com/rust-lang/crates.io-index)" = "4dddda59aaab719767ab11d3efd9a714e95b610c4445d4435765021e9d52dfb1"
+"checksum crc-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "d39e20c5689f196f13d537b1004788990995cfe91b5be7aefaef77ec1ca4f6f8"
+"checksum crossbeam-deque 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "fe8153ef04a7594ded05b427ffad46ddeaf22e63fd48d42b3e1e3bb4db07cae7"
+"checksum crossbeam-epoch 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2af0e75710d6181e234c8ecc79f14a97907850a541b13b0be1dd10992f2e4620"
+"checksum crossbeam-utils 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)" = "d636a8b3bcc1b409d7ffd3facef8f21dcb4009626adbd0c5e6c4305c07253c7b"
+"checksum deflate 0.7.18 (registry+https://github.com/rust-lang/crates.io-index)" = "32c8120d981901a9970a3a1c97cf8b630e0fa8c3ca31e75b6fd6fd5f9f427b31"
 "checksum encoding 0.2.33 (registry+https://github.com/rust-lang/crates.io-index)" = "6b0d943856b990d12d3b55b359144ff341533e516d94098b1d3fc1ac666d36ec"
 "checksum encoding-index-japanese 1.20141219.5 (registry+https://github.com/rust-lang/crates.io-index)" = "04e8b2ff42e9a05335dbf8b5c6f7567e5591d0d916ccef4e0b1710d32a0d0c91"
 "checksum encoding-index-korean 1.20141219.5 (registry+https://github.com/rust-lang/crates.io-index)" = "4dc33fb8e6bcba213fe2f14275f0963fd16f0a02c878e3095ecfdf5bee529d81"
@@ -613,53 +1086,100 @@ dependencies = [
 "checksum encoding-index-singlebyte 1.20141219.5 (registry+https://github.com/rust-lang/crates.io-index)" = "3351d5acffb224af9ca265f435b859c7c01537c0849754d3db3fdf2bfe2ae84a"
 "checksum encoding-index-tradchinese 1.20141219.5 (registry+https://github.com/rust-lang/crates.io-index)" = "fd0e20d5688ce3cab59eb3ef3a2083a5c77bf496cb798dc6fcdb75f323890c18"
 "checksum encoding_index_tests 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "a246d82be1c9d791c5dfde9a2bd045fc3cbba3fa2b11ad558f27d01712f00569"
-"checksum fnv 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)" = "6cc484842f1e2884faf56f529f960cc12ad8c71ce96cc7abba0a067c98fee344"
+"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)" = "2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3"
 "checksum fuchsia-zircon 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "f6c0581a4e363262e52b87f59ee2afe3415361c6ec35e665924eb08afe8ff159"
+"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82"
 "checksum fuchsia-zircon-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "43f3795b4bae048dc6123a6b972cadde2e676f9ded08aef6bb77f5f157684a82"
+"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7"
+"checksum futures 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)" = "1a70b146671de62ec8c8ed572219ca5d594d9b06c0b364d5e67b722fc559b48c"
+"checksum futures-cpupool 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)" = "ab90cde24b3319636588d0c35fe03b1333857621051837ed769faefb4c2162e4"
 "checksum getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)" = "65922871abd2f101a2eb0eaebadc66668e54a87ad9c3dd82520b5f86ede5eff9"
-"checksum heatmap 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)" = "2e718532c484d0bb83c317ec560a2261d0404caead1e3c0db0fdf726964ca379"
-"checksum histogram 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)" = "6162da8402c959c4d4592e905e490108cac43ff1078c6d3afef4423d1bb42de5"
+"checksum h2 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)" = "8111e316d0589775ee2bd671cdfdf3f63c9d97e21d8d16a88bb73dcf99bef7f5"
+"checksum heatmap 0.6.6 (registry+https://github.com/rust-lang/crates.io-index)" = "4c9551a9016b91c9b81fbc093e5ad0dd11c80ff4082fd2266170a210c2890051"
+"checksum histogram 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)" = "12cb882ccb290b8646e554b157ab0b71e64e8d5bef775cd66b6531e52d302669"
+"checksum hpack 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "3d2da7d3a34cf6406d9d700111b8eafafe9a251de41ae71d8052748259343b58"
 "checksum hsl 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "575fb7f1167f3b88ed825e90eb14918ac460461fdeaa3965c6a50951dee1c970"
+"checksum http 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)" = "6861b042450b6333fa7212b6edffc2d6df22579042817d59d49f4f8afbaaaf74"
+"checksum httparse 1.2.4 (registry+https://github.com/rust-lang/crates.io-index)" = "c2f407128745b78abc95c0ffbe4e5d37427fdc0d45470710cfef8c44522a2e37"
+"checksum hyper 0.12.1 (registry+https://github.com/rust-lang/crates.io-index)" = "6416251e6672bff06fe96a3337570772845a44500fba2d178e2e55e0fab58a86"
+"checksum hyper 0.9.18 (registry+https://github.com/rust-lang/crates.io-index)" = "1b9bf64f730d6ee4b0528a5f0a316363da9d8104318731509d4ccc86248f82b3"
+"checksum idna 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "014b298351066f1512874135335d62a789ffe78a9974f94b43ed5621951eaf7d"
+"checksum indexmap 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "08173ba1e906efb6538785a8844dd496f5d34f0a2d88038e95195172fc667220"
 "checksum inflate 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "d1238524675af3938a7c74980899535854b88ba07907bb1c944abe5b8fc437e5"
-"checksum iovec 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "b6e8b9c2247fcf6c6a1151f1156932be5606c9fd6f55a2d7f9fc1cb29386b2f7"
+"checksum iovec 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08"
 "checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d"
-"checksum lazycell 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)" = "3b585b7a6811fb03aa10e74b278a0f00f8dd9b45dc681f148bb29fa5cb61859b"
-"checksum libc 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)" = "56cce3130fd040c28df6f495c8492e5ec5808fb4c9093c310df02b0c8f030148"
-"checksum log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)" = "880f77541efa6e5cc74e76910c9884d9859683118839d6a1dc3b11e63512565b"
+"checksum language-tags 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "a91d884b6667cd606bb5a69aa0c99ba811a115fc68915e7056ec08a46e93199a"
+"checksum lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "76f033c7ad61445c5b347c7382dd1237847eb1bce590fe50365dcb33d546be73"
+"checksum lazy_static 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "e6412c5e2ad9584b0b8e979393122026cdd6d2a80b933f890dcd694ddbe73739"
+"checksum lazycell 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)" = "a6f08839bc70ef4a3fe1d566d5350f519c5912ea86be0df1740a7d247c7fc0ef"
+"checksum libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)" = "b685088df2b950fccadf07a7187c8ef846a959c142338a48f9dc0b94517eb5f1"
+"checksum log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)" = "e19e8d5c34a3e0e2223db8e060f9e8264aeeb5c5fc64a4ee9965c062211c024b"
+"checksum log 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "6fddaa003a65722a7fb9e26b0ce95921fe4ba590542ced664d8ce2fa26f9f3ac"
 "checksum log-panics 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "26bbb657dd8a31b920792fba3fc60f2c18e9477931c0e01afed98116aa0056a7"
-"checksum magenta 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "4bf0336886480e671965f794bc9b6fce88503563013d1bfb7a502c81fe3ac527"
-"checksum magenta-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "40d014c7011ac470ae28e2f76a02bfea4a8480f73e701353b49ad7a8d75f4699"
 "checksum matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)" = "100aabe6b8ff4e4a7e32c1c13523379802df0772b82466207ac25b013f193376"
-"checksum mio 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)" = "dbd91d3bfbceb13897065e97b2ef177a09a438cb33612b2d371bf568819a9313"
+"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3"
+"checksum mime 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)" = "ba626b8a6de5da682e1caa06bdb42a335aee5a84db8e5046a3e8ab17ba0a3ae0"
+"checksum mio 0.6.14 (registry+https://github.com/rust-lang/crates.io-index)" = "6d771e3ef92d58a8da8df7d6976bfca9371ed1de6619d9d5a5ce5b1f29b85bfe"
 "checksum miow 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "8c1f2f3b1cf331de6896aabf6e9d55dca90356cc9960cca7eaaf408a355ae919"
 "checksum mpmc 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "e93e6c806a89abce6b59d120fd62cc9e424afc532453c5ce97328127171dda69"
-"checksum net2 0.2.31 (registry+https://github.com/rust-lang/crates.io-index)" = "3a80f842784ef6c9a958b68b7516bc7e35883c614004dd94959a4dca1b716c09"
-"checksum nodrop 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)" = "52cd74cd09beba596430cc6e3091b74007169a56246e1262f0ba451ea95117b2"
-"checksum num 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)" = "a311b77ebdc5dd4cf6449d81e4135d9f0e3b153839ac90e648a8ef538f923525"
-"checksum num-integer 0.1.35 (registry+https://github.com/rust-lang/crates.io-index)" = "d1452e8b06e448a07f0e6ebb0bb1d92b8890eea63288c0b627331d53514d0fba"
-"checksum num-iter 0.1.34 (registry+https://github.com/rust-lang/crates.io-index)" = "7485fcc84f85b4ecd0ea527b14189281cf27d60e583ae65ebc9c088b13dffe01"
-"checksum num-traits 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)" = "99843c856d68d8b4313b03a17e33c4bb42ae8f6610ea81b28abe076ac721b9b0"
-"checksum odds 0.2.25 (registry+https://github.com/rust-lang/crates.io-index)" = "c3df9b730298cea3a1c3faa90b7e2f9df3a9c400d0936d6015e6165734eefcba"
+"checksum net2 0.2.32 (registry+https://github.com/rust-lang/crates.io-index)" = "9044faf1413a1057267be51b5afba8eb1090bd2231c693664aa1db716fe1eae0"
+"checksum nodrop 0.1.12 (registry+https://github.com/rust-lang/crates.io-index)" = "9a2228dca57108069a5262f2ed8bd2e82496d2e074a06d1ccc7ce1687b6ae0a2"
+"checksum num 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)" = "4703ad64153382334aa8db57c637364c322d3372e097840c72000dabdcf6156e"
+"checksum num-integer 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)" = "6ac0ea58d64a89d9d6b7688031b3be9358d6c919badcf7fbb0527ccfd891ee45"
+"checksum num-iter 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)" = "af3fdbbc3291a5464dc57b03860ec37ca6bf915ed6ee385e7c6c052c422b2124"
+"checksum num-traits 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)" = "775393e285254d2f5004596d69bb8bc1149754570dcc08cf30cabeba67955e28"
+"checksum num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)" = "c51a3322e4bca9d212ad9a158a02abc6934d005490c054a2778df73a70aa0a30"
+"checksum odds 0.2.26 (registry+https://github.com/rust-lang/crates.io-index)" = "4eae0151b9dacf24fcc170d9995e511669a082856a91f958a2fe380bfab3fb22"
 "checksum pad 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "d1bf3336e626b898e7263790d432a711d4277e22faea20dd9f70e0cab268fa58"
+"checksum percent-encoding 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "31010dd2e1ac33d5b46a5b413495239882813e0369f8ed8a5e266f173602f831"
 "checksum png 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "48f397b84083c2753ba53c7b56ad023edb94512b2885ffe227c66ff7edb61868"
+"checksum prometheus 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "760293453bee1de0a12987422d7c4885f7ee933e4417bb828ed23f7d05c3c390"
+"checksum protobuf 2.0.2 (registry+https://github.com/rust-lang/crates.io-index)" = "a163be69698a5cb7baa28819474344d3a268b3f3e41877e61d5555e3d3add1af"
+"checksum quick-error 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)" = "7ac990ab4e038dd8481a5e3fd00641067fcfc674ad663f3222752ed5284e05d4"
 "checksum rand 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)" = "61efcbcd9fa8d8fbb07c84e34a8af18a1ff177b449689ad38a6e9457ecc7b2ae"
-"checksum ratelimit 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "c2587e63d5dd371de267bab5f73e32306bf457a3b1f389983a1b2c40b36d581f"
-"checksum redox_syscall 0.1.31 (registry+https://github.com/rust-lang/crates.io-index)" = "8dde11f18c108289bef24469638a04dce49da56084f2d50618b226e47eb04509"
+"checksum rand 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "eba5f8cb59cc50ed56be8880a5c7b496bfd9bd26394e176bc67884094145c2c5"
+"checksum redox_syscall 0.1.40 (registry+https://github.com/rust-lang/crates.io-index)" = "c214e91d3ecf43e9a4e41e578973adeb14b474f2bee858742d127af75a0112b1"
 "checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)" = "dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda"
 "checksum rusttype 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "07b8848db3b5b5ba97020c6a756c0fdf2dbf2ad7c0d06aa4344a3f2f49c3fe17"
-"checksum serde 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)" = "6a7046c9d4c6c522d10b2d098f9bebe2bef227e0e74044d8c1bfcf6b476af799"
+"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)" = "94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27"
+"checksum serde 1.0.66 (registry+https://github.com/rust-lang/crates.io-index)" = "e9a2d9a9ac5120e0f768801ca2b58ad6eec929dc9d1d616c162f208869c2ce95"
 "checksum shuteye 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)" = "3ee4f453e0b171800d5ab8e3031009107faa0ce9243c6718bee9d9303ec08efc"
 "checksum simple_logger 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "d5a3b341928cec79e536fe62b75bfe2e35891a5e65801ebfbd2741dddf7d7fac"
 "checksum slab 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)" = "17b4fcaed89ab08ef143da37bc52adbcc04d4a69014f4c1208d6b51f0c47bc23"
+"checksum slab 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "fdeff4cd9ecff59ec7e3744cbca73dfe5ac35c2aedb2cfba8a1c715a18912e9d"
+"checksum solicit 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)" = "172382bac9424588d7840732b250faeeef88942e37b6e35317dce98cafdd75b2"
+"checksum spin 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)" = "14db77c5b914df6d6173dda9a3b3f5937bd802934fa5edaf934df06a3491e56f"
 "checksum stb_truetype 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "fcf3270840fc9de208d63e836eb3fdebb85379e7532f42f1b2cbd505fb6fda08"
-"checksum tic 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)" = "b430518516916da193a0e291754fa906101428802c04ac6fdf92ff81d8b01a7e"
+"checksum string 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "31f98b200e7caca9efca50fc0aa69cd58a5ec81d5f6e75b2f3ecaad2e998972a"
 "checksum time 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)" = "d5d788d3aa77bc0ef3e9621256885555368b47bd495c13dd2e7413c89f845520"
-"checksum tiny_http 0.5.8 (registry+https://github.com/rust-lang/crates.io-index)" = "016f040cfc9b5be610de3619eaaa57017fa0b0b678187327bde75fc146e2a41f"
+"checksum tiny_http 0.5.9 (registry+https://github.com/rust-lang/crates.io-index)" = "2f4d55c9a213880d1f0c89ded183f209c6e45b912ca6c7df6f93c163773572e1"
+"checksum tokio 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "8ee337e5f4e501fc32966fec6fe0ca0cc1c237b0b1b14a335f8bfe3c5f06e286"
+"checksum tokio-codec 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "881e9645b81c2ce95fcb799ded2c29ffb9f25ef5bef909089a420e5961dd8ccb"
+"checksum tokio-executor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "8cac2a7883ff3567e9d66bb09100d09b33d90311feca0206c7ca034bc0c55113"
+"checksum tokio-fs 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "fc42bae2f6e33865b99069d95bcddfc85c9f0849b4e7e7399eeee71956ef34d7"
+"checksum tokio-io 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "a5c9635ee806f26d302b8baa1e145689a280d8f5aa8d0552e7344808da54cc21"
+"checksum tokio-reactor 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "e00ec63bbec2c97ce1178cb0587b2c438b2f6b09d3ee54a33c45a9cf0d530810"
+"checksum tokio-tcp 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ec9b094851aadd2caf83ba3ad8e8c4ce65a42104f7b94d9e6550023f0407853f"
+"checksum tokio-threadpool 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "b3c3873a6d8d0b636e024e77b9a82eaab6739578a06189ecd0e731c7308fbc5d"
+"checksum tokio-timer 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)" = "028b94314065b90f026a21826cffd62a4e40a92cda3e5c069cc7b02e5945f5e9"
+"checksum tokio-udp 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "43eb534af6e8f37d43ab1b612660df14755c42bd003c5f8d2475ee78cc4600c0"
 "checksum toml 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "b0601da6c97135c8d330c7a13a013ca6cd4143221b01de2f8d4edc50a9e551c7"
-"checksum unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "bf3a113775714a22dcb774d8ea3655c53a32debae63a063acc00a91cc586245f"
+"checksum traitobject 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)" = "07eaeb7689bb7fca7ce15628319635758eda769fed481ecfe6686ddef2600616"
+"checksum try-lock 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ee2aa4715743892880f70885373966c83d73ef1b0838a664ef0c76fffd35e7c2"
+"checksum typeable 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "1410f6f91f21d1612654e7cc69193b0334f909dcf2c790c4826254fbb86f8887"
+"checksum unicase 1.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "7f4765f83163b74f957c797ad9253caf97f103fb064d3999aea9568d09fc8a33"
+"checksum unicode-bidi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)" = "49f2bd0c6468a8230e1db229cff8029217cf623c767ea5d60bfbd42729ea54d5"
+"checksum unicode-normalization 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "6a0180bc61fc5a987082bfa111f4cc95c4caff7f9799f3e46df09163a937aa25"
+"checksum unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)" = "882386231c45df4700b275c7ff55b6f3698780a650026380e72dabe76fa46526"
 "checksum url 0.2.38 (registry+https://github.com/rust-lang/crates.io-index)" = "cbaa8377a162d88e7d15db0cf110c8523453edcbc5bc66d2b6fffccffa34a068"
+"checksum url 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "f808aadd8cfec6ef90e4a14eb46f24511824d1ac596b9682703c87056c8678b7"
 "checksum uuid 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)" = "78c590b5bd79ed10aad8fb75f078a59d8db445af6c743e55c4a53227fc01c13f"
-"checksum waterfall 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "d064d35e8d8167949da128367d18338025e0f752f7f1783c04bc41017a72026d"
+"checksum version_check 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "6b772017e347561807c1aa192438c5fd74242a670a6cffacc40f2defd1dc069d"
+"checksum want 0.0.4 (registry+https://github.com/rust-lang/crates.io-index)" = "a05d9d966753fa4b5c8db73fcab5eed4549cfe0e1e4e66911e5564a0085c35d1"
+"checksum waterfall 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ddfd2a19feb20d152820c6d01acfda726c305fa7ea67f685359d24f4d6040729"
 "checksum winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)" = "167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a"
+"checksum winapi 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)" = "773ef9dcc5f24b7d850d0ff101e542ff24c3b090a9768e03ff889fdef41f00fd"
 "checksum winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc"
+"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
 "checksum ws2_32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "d59cefebd0c892fa2dd6de581e937301d8552cb44489cdff035c6187cb63fa5e"
diff --git a/Cargo.toml b/Cargo.toml
index 42f73cb..71a9bba 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -40,18 +40,26 @@ codegen-units = 1
 byteorder = "=1.1.0"
 bytes = "=0.3.0"
 crc = "=1.5.0"
+fnv = "1.0.5"
 getopts = "=0.2.15"
+histogram = "0.6.6"
+hyper = "0.12"
+lazy_static = "0.2"
+libc = {version = "0.2", optional = true}
 log = "0.3.8"
 log-panics = "=1.1.0"
-mio = "=0.6.10"
+mio = "=0.6.14"
 mpmc = "=0.1.2"
 pad = "=0.1.4"
+prometheus = {version = "=0.4.2", features = ["push"]}
 rand = "=0.3.17"
-ratelimit = "=0.4.2"
+#ratelimit = "=0.4.2"
+ratelimit = { path = "ratelimit" }
 shuteye = "=0.3.2"
 slab = "=0.3.0"
 simple_logger = "=0.4.0"
-tic = "=0.2.4"
+#tic = "=0.2.4"
+tic = { path = "tic" }
 time = "=0.1.38"
 toml = "=0.4.2"
 
@@ -60,3 +68,4 @@ asm = [ "tic/asm" ]
 default = []
 unstable = []
 benchcmp = []
+push = ["libc"]
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..e4f4138
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,26 @@
+# Building rpc-perf.
+FROM centos:7 AS rpc-perf
+
+ENV RUSTUP_HOME=/usr/local/rustup \
+    CARGO_HOME=/usr/local/cargo \
+    PATH=/usr/local/cargo/bin:$PATH \
+    RUST_VERSION=1.26.2
+
+RUN yum install -y gcc git make wget patch
+
+RUN curl https://sh.rustup.rs -sSf | \
+    sh -s -- --default-toolchain stable -y
+
+#RUN source /root/.cargo/env
+
+WORKDIR /rpc-perf-intel
+
+ADD . .
+
+RUN cargo build --release
+
+# Builing final container that consists of workloads only.
+FROM centos:7
+
+COPY --from=rpc-perf /rpc-perf-intel/target/release/rpc-perf /usr/bin/
+COPY --from=rpc-perf /rpc-perf-intel/configs /usr/bin/configs
diff --git a/README_WC.md b/README_WC.md
new file mode 100644
index 0000000..63ac4cf
--- /dev/null
+++ b/README_WC.md
@@ -0,0 +1,12 @@
+[Build]
+cargo build --release
+
+[Run]
+./target/release/rpc-perf --config configs/sinus_workload.toml --server 127.0.0.1:11211
+
+
+Duration using in ratelimte. Function is 1/x
+rate 4000 -> Duration { secs: 0, nanos: 250000 }
+rate 3000 -> Duration { secs: 0, nanos: 333333 }
+rate 2000 -> Duration { secs: 0, nanos: 500000 } 
+rate 1000 -> Duration { secs: 0, nanos: 1_000_000 } 
\ No newline at end of file
diff --git a/configs/mixed_workload.toml b/configs/mixed_workload.toml
index 00592b7..da0ec4d 100644
--- a/configs/mixed_workload.toml
+++ b/configs/mixed_workload.toml
@@ -5,6 +5,15 @@
 [general]
 request-timeout = 200
 connect-timeout = 500
+threads = 4
+connections = 4
+duration = 1
+windows = 6
+protocol = "memcache"
+tcp-nodelay = false
+ipv4 = true
+ipv6 = true
+database = 0
 
 [[workload]]
 name = "get"
diff --git a/configs/sinus_workload.toml b/configs/sinus_workload.toml
new file mode 100644
index 0000000..fd03810
--- /dev/null
+++ b/configs/sinus_workload.toml
@@ -0,0 +1,28 @@
+# this example runs a mixed key-value workload suitable for memcache and redis
+# gets and sets occur on a 3byte keyspace with set injecting 4 byte values
+# read/write 80%/20% at 50kqps aggregate
+
+[general]
+request-timeout = 200
+connect-timeout = 500
+threads = 4
+connections = 1
+duration = 1
+windows = 300
+protocol = "memcache"
+tcp-nodelay = false
+ipv4 = true
+ipv6 = true
+database = 0
+
+[[workload]]
+name = "get"
+method = "get"
+rate = 2000
+period = 15
+amplitude = 1000
+  [[workload.parameter]]
+  style = "random"
+  size = 3
+  regenerate = true
+
diff --git a/configs/thrift_calc.toml b/configs/thrift_calc.toml
index 2fc6eee..11b4588 100644
--- a/configs/thrift_calc.toml
+++ b/configs/thrift_calc.toml
@@ -45,17 +45,17 @@ rate = 1
   [[workload.parameter]]
   id = 2 # this is the work struct
   type = "struct"
-  [[workload.parameter]]
-  id = 1 # this is the thing to subtract from
-  type = "i32"
-  seed = 15 # here is the value
-  [[workload.parameter]]
-  id = 2 # here is the thing to subtract
-  type = "i32"
-  seed = 10 # here is the value
-  [[workload.parameter]]
-  id = 3 # this is the op type field
-  type = "i32"
-  seed = 2 # 2 is for subtration
-  [[workload.parameter]]
-  type = "stop" #required to end the struct
+      [[workload.parameter]]
+      id = 1 # this is the thing to subtract from
+      type = "i32"
+      seed = 15 # here is the value
+      [[workload.parameter]]
+      id = 2 # here is the thing to subtract
+      type = "i32"
+      seed = 10 # here is the value
+      [[workload.parameter]]
+      id = 3 # this is the op type field
+      type = "i32"
+      seed = 2 # 2 is for subtration
+      [[workload.parameter]]
+      type = "stop" #required to end the struct
diff --git a/ratelimit/.gitignore b/ratelimit/.gitignore
new file mode 100644
index 0000000..4ef0b95
--- /dev/null
+++ b/ratelimit/.gitignore
@@ -0,0 +1,5 @@
+*.bk
+*.swp
+*~
+Cargo.lock
+target
diff --git a/ratelimit/.travis.yml b/ratelimit/.travis.yml
new file mode 100644
index 0000000..1bb2bb3
--- /dev/null
+++ b/ratelimit/.travis.yml
@@ -0,0 +1,24 @@
+language: rust
+cache: cargo
+rust:
+- stable
+- beta
+- nightly
+os: linux
+env: TYPE=default RUST_BACKTRACE=1
+matrix:
+  include:
+    - os: linux
+      rust: nightly
+      env: TYPE=bench RUST_BACKTRACE=1
+      script: cargo bench --features unstable
+    - os: linux
+      rust: nightly
+      env: TYPE=rustfmt RUST_BACKTRACE=1
+      script:
+        - (travis_wait 20 cargo install -f rustfmt && cargo fmt -- --write-mode=diff) || exit 0
+    - os: linux
+      rust: nightly
+      env: TYPE=clippy RUST_BACKTRACE=1
+      script:
+        - (travis_wait 20 cargo install -f clippy && cargo clippy) || exit 0
diff --git a/ratelimit/CODE_OF_CONDUCT.md b/ratelimit/CODE_OF_CONDUCT.md
new file mode 100644
index 0000000..1ae1dd7
--- /dev/null
+++ b/ratelimit/CODE_OF_CONDUCT.md
@@ -0,0 +1,27 @@
+# The Code of Conduct
+
+This document is based on the [Rust Code of Conduct](https://www.rust-lang.org/conduct.html) and outlines the standard of conduct which is both expected and enforced as part of this project. You may also view this [Code of Conduct](https://brayniac.github.io/conduct) online.
+
+## Conduct
+
+**Contact**: [conduct@brayniac.org](mailto:conduct@brayniac.org)
+
+* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.
+* Avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.
+* Please be kind and courteous. There's no need to be mean or rude.
+* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.
+* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.
+* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behaviour. We interpret the term "harassment" as including the definition in the <a href="http://citizencodeofconduct.org/">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.
+* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the repository Owners immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.
+* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behaviour is not welcome.
+
+## Moderation
+
+These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation, please use the contact information above, or mention @brayniac in the thread.
+
+1. Remarks that violate this Code of Conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)
+2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.
+
+In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.
+
+And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could've communicated better  remember that it's your responsibility to make your fellow Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.
diff --git a/ratelimit/Cargo.toml b/ratelimit/Cargo.toml
new file mode 100644
index 0000000..87e2cdf
--- /dev/null
+++ b/ratelimit/Cargo.toml
@@ -0,0 +1,26 @@
+[package]
+name = "ratelimit"
+version = "0.4.4-pre"
+authors = ["Brian Martin <brayniac@gmail.com>"]
+
+license = "MIT/Apache-2.0"
+
+description = "a token bucket ratelimiter"
+
+homepage = "https://github.com/brayniac/ratelimit"
+documentation = "https://docs.rs/ratelimit"
+repository = "https://github.com/brayniac/ratelimit"
+
+readme = "README.md"
+
+keywords = [ "ratelimit", "tokenbucket", "rate", "token", "bucket" ]
+
+[dependencies]
+
+[dev-dependencies]
+lazy_static = "0.2.8"
+time = "0.1.40"
+rand = "0.3.17"
+
+[features]
+unstable = []
diff --git a/ratelimit/LICENSE-APACHE b/ratelimit/LICENSE-APACHE
new file mode 100644
index 0000000..397c098
--- /dev/null
+++ b/ratelimit/LICENSE-APACHE
@@ -0,0 +1,202 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2015 Brian Martin and other Histogram contributors
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
diff --git a/ratelimit/LICENSE-MIT b/ratelimit/LICENSE-MIT
new file mode 100644
index 0000000..b58068d
--- /dev/null
+++ b/ratelimit/LICENSE-MIT
@@ -0,0 +1,19 @@
+Copyright (c) 2015 Brian Martin and other Histogram contributors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/ratelimit/README.md b/ratelimit/README.md
new file mode 100644
index 0000000..345ceb9
--- /dev/null
+++ b/ratelimit/README.md
@@ -0,0 +1,62 @@
+# ratelimit - a token bucket ratelimiter for rust
+
+ratelimit provides a token bucket ratelimiter which can be used by a single thread, or shared across threads by using a channel to push tokens to the ratelimiter
+
+The API documentation of this library can be found at
+[docs.rs/ratelimit](https://docs.rs/ratelimit/).
+
+[![conduct-badge][]][conduct] [![travis-badge][]][travis] [![downloads-badge][] ![release-badge][]][crate] [![license-badge][]](#license)
+
+[conduct-badge]: https://img.shields.io/badge/%E2%9D%A4-code%20of%20conduct-blue.svg
+[travis-badge]: https://img.shields.io/travis/brayniac/ratelimit/master.svg
+[downloads-badge]: https://img.shields.io/crates/d/ratelimit.svg
+[release-badge]: https://img.shields.io/crates/v/ratelimit.svg
+[license-badge]: https://img.shields.io/crates/l/ratelimit.svg
+[conduct]: https://brayniac.github.io/conduct
+[travis]: https://travis-ci.org/brayniac/ratelimit
+[crate]: https://crates.io/crates/ratelimit
+[Cargo]: https://github.com/rust-lang/cargo
+
+## Code of Conduct
+
+**NOTE**: All conversations and contributions to this project shall adhere to the [Code of Conduct][conduct]
+
+## Usage
+
+To use `ratelimit`, first add this to your `Cargo.toml`:
+
+```toml
+[dependencies]
+ratelimit = "*"
+```
+
+Then, add this to your crate root:
+
+```rust
+extern crate ratelimit;
+```
+
+## Features
+
+* token bucket ratelimiter
+* single or multi threaded uses
+
+## Future work
+
+* additional ratelimiter models
+
+## License
+
+Licensed under either of
+
+ * Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
+ * MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)
+
+at your option.
+
+### Contribution
+
+Unless you explicitly state otherwise, any contribution intentionally
+submitted for inclusion in the work by you, as defined in the Apache-2.0
+license, shall be dual licensed as above, without any additional terms or
+conditions.
diff --git a/ratelimit/examples/global_ratelimit.rs b/ratelimit/examples/global_ratelimit.rs
new file mode 100644
index 0000000..0916535
--- /dev/null
+++ b/ratelimit/examples/global_ratelimit.rs
@@ -0,0 +1,31 @@
+extern crate ratelimit;
+
+use std::thread;
+use std::time::Instant;
+
+pub fn main() {
+    let mut limiter = ratelimit::Builder::new().build();
+    let handle = limiter.make_handle();
+
+    thread::spawn(move || limiter.run());
+
+    let mut threads = Vec::new();
+    for _ in 0..10 {
+        let handle = handle.clone();
+        threads.push(thread::spawn(move || worker(handle)));
+    }
+    for thread in threads {
+        thread.join().unwrap();
+    }
+}
+
+pub fn worker(mut handle: ratelimit::Handle) {
+    for _ in 0..6 {
+        loop {
+            if handle.try_wait().is_ok() {
+                println!("{:?}", Instant::now());
+                break;
+            }
+        }
+    }
+}
diff --git a/ratelimit/rustfmt.toml b/ratelimit/rustfmt.toml
new file mode 100644
index 0000000..0468aa5
--- /dev/null
+++ b/ratelimit/rustfmt.toml
@@ -0,0 +1,2 @@
+reorder_imports = true
+reorder_imported_names = true
diff --git a/ratelimit/src/lib.rs b/ratelimit/src/lib.rs
new file mode 100644
index 0000000..7df3653
--- /dev/null
+++ b/ratelimit/src/lib.rs
@@ -0,0 +1,750 @@
+//! A token bucket ratelimiter for rust which can be used by either a single
+//! thread or shared across threads using a mpsc synchronous channel
+//!
+//!
+//! # Goals
+//! * a simple token bucket ratelimiter
+//! * usable in single or multi thread code
+//!
+//! # Future work
+//! * consider additional types of ratelimiters
+//!
+//! # Usage
+//!
+//! Construct a new `Limiter` and call block between actions. For multi-thread
+//! clone the channel sender to pass to the threads, in a separate thread, call
+//! run on the `Limiter` in a tight loop.
+//!
+//! # Examples
+//!
+//! Construct `Limiter` to do a count-down.
+//!
+//! ```
+//! extern crate ratelimit;
+//!
+//! use std::time::Duration;
+//!
+//! let mut ratelimit = ratelimit::Builder::new()
+//!     .capacity(1) //number of tokens the bucket will hold
+//!     .quantum(1) //add one token per interval
+//!     .interval(Duration::new(1, 0)) //add quantum tokens every 1 second
+//!     .build();
+//!
+//! // count down to ignition
+//! println!("Count-down....");
+//! for i in -10..0 {
+//!     println!("T {}", i);
+//!     ratelimit.wait();
+//! }
+//! println!("Ignition!");
+//! ```
+//!
+//! Use the `Limiter` to ratelimit multi-threaded cases
+//!
+//! ```
+//! extern crate ratelimit;
+//!
+//! use std::thread;
+//! use std::time::{Duration, Instant};
+//!
+//! let mut ratelimit = ratelimit::Builder::new()
+//!     .capacity(1) //number of tokens the bucket will hold
+//!     .quantum(1) //add one token per interval
+//!     .interval(Duration::new(1, 0)) //add quantum tokens every 1 second
+//!     .build();
+//! let mut handle = ratelimit.make_handle();
+//! thread::spawn(move || { ratelimit.run() });
+//!
+//! // launch threads
+//! let mut threads = Vec::new();
+//! for _ in 0..10 {
+//!     let mut handle = handle.clone();
+//!     threads.push(thread::spawn(move || {
+//!         handle.wait();
+//!         println!("current time: {:?}", Instant::now());
+//!     }));
+//! }
+//! for thread in threads {
+//!     thread.join().unwrap();
+//! }
+//! println!("time's up!");
+//! ```
+
+#![cfg_attr(feature = "cargo-clippy", deny(missing_docs))]
+#![cfg_attr(feature = "cargo-clippy", deny(warnings))]
+#![cfg_attr(feature = "unstable", feature(test))]
+
+#[cfg(feature = "unstable")]
+extern crate test;
+
+use std::sync::mpsc;
+use std::thread::sleep;
+use std::time::{Duration, Instant};
+
+/// A builder for a rate limiter.
+pub struct Builder {
+    start: Instant,
+    capacity: u32,
+    quantum: u32,
+    interval: Duration,
+    time: Instant,
+    amplitude: i64,
+    period: i64,
+    phase: i64,
+    rate: u32,
+}
+
+/// Single-threaded rate limiter.
+pub struct Limiter {
+    config: Builder,
+    t0: Instant,
+    available: f64,
+    tx: Handle,
+    rx: mpsc::Receiver<()>,
+}
+
+/// Handler for a multi-threaded rate-limiter.
+#[derive(Clone)]
+pub struct Handle {
+    inner: mpsc::SyncSender<()>,
+    available: usize,
+}
+unsafe impl Sync for Handle {}
+
+impl Handle {
+    /// Block for 1 token
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Builder;
+    /// # use std::thread;
+    /// let mut limiter = Builder::default().build();
+    /// let mut handle = limiter.make_handle();
+    ///
+    /// thread::spawn(move || { limiter.run() });
+    ///
+    /// let mut threads = Vec::new();
+    ///
+    /// for i in 0..2 {
+    ///     let mut handle = handle.clone();
+    ///     threads.push(thread::spawn(move || {
+    ///         for x in 0..5 {
+    ///             handle.wait();
+    ///             println!(".");
+    ///         }
+    ///     }));
+    /// }
+    pub fn wait(&mut self) {
+        if self.available >= 1 {
+            self.available -= 1;
+        } else {
+            loop {
+                if self.inner.try_send(()).is_ok() {
+                    break;
+                }
+                sleep(Duration::new(0, 1_000));
+            }
+        }
+    }
+
+    /// Block for `count` tokens
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Builder;
+    /// # use std::thread;
+    /// let mut limiter = Builder::default().build();
+    /// let mut handle = limiter.make_handle();
+    ///
+    /// thread::spawn(move || { limiter.run() });
+    ///
+    /// let mut threads = Vec::new();
+    ///
+    /// for i in 0..2 {
+    ///     let mut handle = handle.clone();
+    ///     threads.push(thread::spawn(move || {
+    ///         for x in 0..5 {
+    ///             handle.wait_for(1);
+    ///             println!(".");
+    ///         }
+    ///     }));
+    /// }
+    pub fn wait_for(&mut self, count: usize) {
+        for _ in 0..count {
+            self.wait();
+        }
+    }
+
+    /// Non-blocking wait for one token.
+    /// Returns Ok(()) if no wait required.
+    /// Returns Err(()) if wait would block.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Builder;
+    /// let mut limiter = Builder::new().build();
+    /// let mut handle = limiter.make_handle();
+    ///
+    /// if handle.try_wait().is_ok() {
+    ///     println!("token granted");
+    /// } else {
+    ///     println!("would block");
+    /// }
+    pub fn try_wait(&mut self) -> Result<(), ()> {
+        self.try_wait_for(1)
+    }
+
+    /// Non-blocking wait for `count` token.
+    /// Returns Ok(()) if no wait required.
+    /// Returns Err(()) if wait would block.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Builder;
+    /// let mut limiter = Builder::new().build();
+    /// let mut handle = limiter.make_handle();
+    ///
+    /// if handle.try_wait_for(2).is_ok() {
+    ///     println!("tokens granted");
+    /// } else {
+    ///     println!("would block");
+    /// }
+    pub fn try_wait_for(&mut self, count: usize) -> Result<(), ()> {
+        if count <= self.available {
+            self.available -= count;
+            Ok(())
+        } else {
+            let needed = count - self.available;
+            for _ in 0..needed {
+                if self.inner.try_send(()).is_ok() {
+                    self.available += 1;
+                } else {
+                    break;
+                }
+            }
+            if self.available == count {
+                self.available = 0;
+                Ok(())
+            } else {
+                Err(())
+            }
+        }
+    }
+}
+
+impl Builder {
+    /// Creates a new Builder with the default config
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Builder;
+    /// let mut b = Builder::new();
+    pub fn new() -> Builder {
+        Builder::default()
+    }
+
+
+    /// Returns a Limiter from the Builder.
+    ///
+    /// # Example
+    /// ```
+    /// # use ratelimit::Builder;
+    ///
+    /// let mut r = Builder::new().build();
+    pub fn build(self) -> Limiter {
+        Limiter::configured(self)
+    }
+
+    /// Sets the number of tokens to add per interval.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Limiter;
+    ///
+    /// let mut r = Limiter::configure()
+    ///     .quantum(100)
+    ///     .build();
+    pub fn quantum(mut self, quantum: u32) -> Self {
+        self.quantum = quantum;
+        self
+    }
+
+    /// Sets the number of tokens that the bucket can hold.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Limiter;
+    ///
+    /// let mut r = Limiter::configure()
+    ///     .capacity(100)
+    ///     .build();
+    pub fn capacity(mut self, capacity: u32) -> Self {
+        self.capacity = capacity;
+        self
+    }
+
+    /// Set the duration between token adds.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Limiter;
+    /// # use std::time::Duration;
+    ///
+    /// let mut r = Limiter::configure()
+    ///     .interval(Duration::new(2, 0))
+    ///     .build();
+    pub fn interval(mut self, interval: Duration) -> Self {
+        self.interval = interval;
+        self
+    }
+
+    /// Alternative to `interval`; sets the number of times
+    /// that tokens will be added to the bucket each second.
+    ///
+    /// # Examples
+    ///
+    /// ```
+    /// # use ratelimit::Limiter;
+    ///
+    /// let mut rate = 100_000; // 100kHz
+    /// let mut r = Limiter::configure()
+    ///     .frequency(rate)
+    ///     .build();
+    pub fn frequency(mut self, cycles: u32) -> Self {
+        let mut interval = Duration::new(1, 0);
+        interval /= cycles;
+        self.interval = interval;
+        self.rate = cycles;
+        self
+    }
+
+    pub fn amplitude(mut self, amplitude: i64) -> Self {
+        self.amplitude = amplitude;
+        self
+    }
+
+    pub fn period(mut self, period: i64) -> Self {
+        self.period = period;
+        self
+    }
+
+    pub fn phase(mut self, phase: i64) -> Self {
+        self.phase = phase;
+        self
+    }
+}
+
+impl Default for Builder {
+    fn default() -> Self {
+        Self {
+            start: Instant::now(),
+            capacity: 1,
+            quantum: 1,
+            interval: Duration::new(1, 0),
+            time: Instant::now(),
+            amplitude: 1,
+            period: 1,
+            phase: 0,
+            rate: 1,
+        }
+    }
+}
+
+impl Default for Limiter {
+    fn default() -> Limiter {
+        Builder::default().build()
+    }
+}
+
+impl Limiter {
+    /// create a new default ratelimit instance
+    ///
+    /// # Example
+    /// ```
+    /// # use ratelimit::Limiter;
+    ///
+    /// let mut r = Limiter::new();
+    pub fn new() -> Limiter {
+        Default::default()
+    }
+
+    /// create a new `Config` for building a custom `Limiter`
+    ///
+    /// # Example
+    /// ```
+    /// # use ratelimit::Limiter;
+    ///
+    /// let mut r = Limiter::configure().build();
+    pub fn configure() -> Builder {
+        Builder::default()
+    }
+
+    // internal function for building a Limiter from its Config
+    fn configured(config: Builder) -> Limiter {
+        let (tx, rx) = mpsc::sync_channel(config.capacity as usize);
+        for _ in 0..config.capacity {
+            let _ = tx.send(());
+        }
+        let t0 = config.start;
+        Limiter {
+            config: config,
+            t0: t0,
+            available: 0.0,
+            tx: Handle {
+                inner: tx,
+                available: 0,
+            },
+            rx: rx,
+        }
+    }
+
+    /// Run the limiter, intended for multi-threaded use
+    ///
+    /// # Example
+    /// ```
+    /// # use ratelimit::Limiter;
+    /// # use std::thread;
+    ///
+    /// let mut limiter = Limiter::new();
+    ///
+    /// let mut handle = limiter.make_handle();
+    ///
+    /// thread::spawn(move || { limiter.run(); });
+    ///
+    /// handle.wait();
+    pub fn run(&mut self) {
+        // pre-fill the queue
+        loop {
+            if self.tx.inner.try_send(()).is_err() {
+                break;
+            }
+        }
+        // set available to 0
+        self.available = 0.0;
+        // reset t0
+        self.t0 = Instant::now();
+        loop {
+            self.run_once();
+        }
+    }
+
+    /// Run the limiter for a single tick
+    fn run_once(&mut self) {
+        let quantum = self.config.quantum as usize;
+        self.wait_for(quantum);
+        let mut unused = 0;
+        for _ in 0..self.config.quantum {
+            match self.rx.try_recv() {
+                Ok(..) => {}
+                Err(_) => {
+                    unused += 1;
+                }
+            }
+        }
+        self.give(f64::from(unused));
+    }
+
+    /// Create a Handle for multi-thread use
+    ///
+    /// # Example
+    /// ```
+    /// # use ratelimit::Limiter;
+    ///
+    /// let mut limiter = Limiter::new();
+    ///
+    /// let mut handle = limiter.make_handle();
+    ///
+    /// match handle.try_wait() {
+    ///     Ok(_) => {
+    ///         println!("not limited");
+    ///     },
+    ///     Err(_) => {
+    ///         println!("was limited");
+    ///     },
+    /// }
+    pub fn make_handle(&mut self) -> Handle {
+        self.tx.clone()
+    }
+
+    /// Blocking wait for 1 token.
+    ///
+    /// # Example
+    /// ```
+    /// # use ratelimit::Limiter;
+    ///
+    /// let mut limiter = Limiter::new();
+    /// for i in -10..0 {
+    ///     println!("T {}...", i);
+    ///     limiter.wait();
+    /// }
+    /// println!("Ignition!");
+    pub fn wait(&mut self) {
+        self.wait_for(1)
+    }
+
+    /// Blocking wait for `count` tokens.
+    ///
+    /// # Example
+    /// ```
+    /// # use ratelimit::Limiter;
+    ///
+    /// let mut limiter = Limiter::new();
+    /// for i in 1..3 {
+    ///     println!("{}...", i);
+    ///     limiter.wait_for(i);
+    /// }
+    pub fn wait_for(&mut self, count: usize) {
+        self.sinus();
+        if let Some(wait) = self.take(Instant::now(), count) {
+            sleep(wait);
+        }
+    }
+
+    // Internal function to add tokens to the bucket
+    fn give(&mut self, count: f64) {
+        self.available += count;
+
+        let capacity = f64::from(self.config.capacity);
+
+        if self.available >= capacity {
+            self.available = capacity;
+        }
+    }
+
+    // Return time to sleep until `count` tokens are available
+    fn take(&mut self, t1: Instant, count: usize) -> Option<Duration> {
+
+        // we don't need any tokens, just return
+        if count == 0 {
+            return None;
+        }
+
+        // we have all tokens we need, fast path
+        if self.available >= count as f64 {
+            self.available -= count as f64;
+            return None;
+        }
+
+        // do the accounting
+        self.tick(t1);
+
+        // do we have the tokens now?
+        if self.available >= count as f64 {
+            self.available -= count as f64;
+            return None;
+        }
+
+        // we must wait
+        let need = count as f64 - self.available;
+        let wait = self.config.interval * need.ceil() as u32;
+        self.available -= count as f64;
+
+        Some(wait)
+    }
+
+    // move the time forward and do bookkeeping
+    fn tick(&mut self, t1: Instant) {
+        let t0 = self.t0;
+        let cycles = cycles(t1.duration_since(t0), self.config.interval);
+        let tokens = cycles * f64::from(self.config.quantum);
+
+        self.give(tokens);
+        self.t0 = t1;
+    }
+
+    fn sinus(&mut self) -> std::time::Duration {
+        let angular_velocity = 2.0 * std::f64::consts::PI / self.config.period as f64;
+
+        let time = self.config.time.elapsed().as_secs() as f64 +
+            (self.config.time.elapsed().subsec_nanos() as f64 / 1_000_000_000.0);
+
+        let variable = (angular_velocity * time + self.config.phase as f64).cos();
+
+        let rate = (self.config.amplitude as f64 * variable + self.config.rate as f64) as u32;
+
+        let mut interval = Duration::new(1, 0);
+        interval /= rate;
+        self.config.interval = interval;
+
+        interval
+    }
+}
+
+// returns the number of cycles of period length within the duration
+fn cycles(duration: Duration, period: Duration) -> f64 {
+    let d = 1_000_000_000 * duration.as_secs() as u64 + u64::from(duration.subsec_nanos());
+    let p = 1_000_000_000 * period.as_secs() as u64 + u64::from(period.subsec_nanos());
+    d as f64 / p as f64
+}
+
+#[cfg(test)]
+mod tests {
+    #[cfg(feature = "unstable")]
+    extern crate test;
+
+    #[cfg(feature = "unstable")]
+    use std::thread;
+
+    use super::*;
+    use std::time::Duration;
+
+    #[test]
+    fn test_cycles() {
+        let d = Duration::new(10, 0);
+        assert_eq!(cycles(d, Duration::new(1, 0)), 10.0);
+
+        let d = Duration::new(1, 500_000_000);
+        assert_eq!(cycles(d, Duration::new(1, 0)), 1.5);
+
+        let d = Duration::new(1, 0);
+        assert_eq!(cycles(d, Duration::new(0, 1000000)), 1000.0);
+
+        let d = Duration::new(1, 0);
+        assert_eq!(cycles(d, Duration::new(0, 2000000)), 500.0);
+
+        let d = Duration::new(0, 1000);
+        assert_eq!(cycles(d, Duration::new(0, 2000000)), 0.0005);
+
+        let d = Duration::new(0, 0);
+        assert_eq!(cycles(d, Duration::new(0, 2000000)), 0.0);
+
+        let d = Duration::new(0, 1);
+        assert_eq!(cycles(d, Duration::new(0, 1)), 1.0);
+    }
+
+    #[test]
+    fn test_give() {
+        let mut r = Builder::default().capacity(1000).build();
+
+        assert_eq!(r.available, 0.0);
+
+        r.give(1.0);
+        assert_eq!(r.available, 1.0);
+
+        r.give(1.5);
+        assert_eq!(r.available, 2.5);
+    }
+
+    #[test]
+    fn test_tick() {
+        let mut r = Builder::default().capacity(1000).build();
+        let t = r.t0;
+        r.tick(t + Duration::new(1, 0));
+        assert_eq!(r.available, 1.0);
+        let t = r.t0;
+        r.tick(t + Duration::new(0, 500_000_000));
+        assert_eq!(r.available, 1.5);
+    }
+
+    #[test]
+    fn test_take() {
+        let mut r = Builder::default().frequency(1000).capacity(1000).build();
+        let t = r.t0;
+        assert_eq!(r.take(t + Duration::new(1, 0), 1000), None);
+        assert_eq!(
+            r.take(t + Duration::new(1, 0), 1000),
+            Some(Duration::new(1, 0))
+        );
+        assert_eq!(
+            r.take(t + Duration::new(2, 0), 1000),
+            Some(Duration::new(1, 0))
+        );
+        assert_eq!(r.take(t + Duration::new(4, 0), 1000), None);
+    }
+
+    #[cfg(feature = "unstable")]
+    #[bench]
+    fn interval_1000ns(b: &mut test::Bencher) {
+        let mut r = Builder::default()
+            .capacity(10000)
+            .interval(Duration::new(0, 1_000))
+            .build();
+        b.iter(|| r.wait());
+    }
+
+    #[cfg(feature = "unstable")]
+    #[bench]
+    fn interval_500ns(b: &mut test::Bencher) {
+        let mut r = Builder::default()
+            .capacity(10000)
+            .interval(Duration::new(0, 500))
+            .build();
+        b.iter(|| r.wait());
+    }
+
+    #[cfg(feature = "unstable")]
+    #[bench]
+    fn interval_100ns(b: &mut test::Bencher) {
+        let mut r = Builder::default()
+            .capacity(10000)
+            .interval(Duration::new(0, 100))
+            .build();
+        b.iter(|| r.wait());
+    }
+
+    #[cfg(feature = "unstable")]
+    #[bench]
+    fn interval_50ns(b: &mut test::Bencher) {
+        let mut r = Builder::default()
+            .capacity(10000)
+            .interval(Duration::new(0, 50))
+            .build();
+        b.iter(|| r.wait());
+    }
+
+    #[cfg(feature = "unstable")]
+    #[bench]
+    fn multi_interval_1000ns(b: &mut test::Bencher) {
+        let mut r = Builder::default()
+            .capacity(10000)
+            .interval(Duration::new(0, 1_000))
+            .build();
+        let mut h = r.make_handle();
+        thread::spawn(move || { r.run(); });
+        b.iter(|| h.wait());
+    }
+
+    #[cfg(feature = "unstable")]
+    #[bench]
+    fn multi_interval_500ns(b: &mut test::Bencher) {
+        let mut r = Builder::default()
+            .capacity(10000)
+            .interval(Duration::new(0, 500))
+            .build();
+        let mut h = r.make_handle();
+        thread::spawn(move || { r.run(); });
+        b.iter(|| h.wait());
+    }
+
+    #[cfg(feature = "unstable")]
+    #[bench]
+    fn multi_interval_100ns(b: &mut test::Bencher) {
+        let mut r = Builder::default()
+            .capacity(10000)
+            .interval(Duration::new(0, 100))
+            .build();
+        let mut h = r.make_handle();
+        thread::spawn(move || { r.run(); });
+        b.iter(|| h.wait());
+    }
+
+    #[cfg(feature = "unstable")]
+    #[bench]
+    fn multi_interval_50ns(b: &mut test::Bencher) {
+        let mut r = Builder::default()
+            .capacity(10000)
+            .interval(Duration::new(0, 50))
+            .build();
+        let mut h = r.make_handle();
+        thread::spawn(move || { r.run(); });
+        b.iter(|| h.wait());
+    }
+}
diff --git a/src/cfgtypes/mod.rs b/src/cfgtypes/mod.rs
index 590daa5..4089ba4 100644
--- a/src/cfgtypes/mod.rs
+++ b/src/cfgtypes/mod.rs
@@ -22,18 +22,36 @@ pub mod tools;
 
 pub type CResult<T> = Result<T, String>;
 
+pub struct SinusParametersWorkload {
+    pub amplitude: i64,
+    pub period: i64,
+    pub phase: i64,
+}
+
+impl SinusParametersWorkload {
+    pub fn new(amplitude: i64, period: i64, phase: i64) -> SinusParametersWorkload {
+        SinusParametersWorkload {
+            amplitude: amplitude,
+            period: period,
+            phase: phase,
+        }
+    }
+}
+
 pub struct BenchmarkWorkload {
     pub name: String,
     pub rate: usize,
     pub gen: Box<ProtocolGen>,
+    pub sinus_parameters: SinusParametersWorkload,
 }
 
 impl BenchmarkWorkload {
-    pub fn new(name: String, rate: usize, gen: Box<ProtocolGen>) -> BenchmarkWorkload {
+    pub fn new(name: String, rate: usize, gen: Box<ProtocolGen>, sinus_parameters: SinusParametersWorkload) -> BenchmarkWorkload {
         BenchmarkWorkload {
             name: name,
             rate: rate,
             gen: gen,
+            sinus_parameters: sinus_parameters,
         }
     }
 }
diff --git a/src/cfgtypes/tools.rs b/src/cfgtypes/tools.rs
index 60c396c..00790a0 100644
--- a/src/cfgtypes/tools.rs
+++ b/src/cfgtypes/tools.rs
@@ -29,3 +29,11 @@ pub fn seeded_string(size: usize, seed: usize) -> String {
     let s = format!("{}", seed);
     s.pad(size, '0', Alignment::Right, true)
 }
+
+pub fn list_string(size: usize) -> String {
+    let an_integer = [1,2,3];
+    let value = an_integer[thread_rng().gen_range(0, 3)];
+    let s = format!("{}", value);
+    debug!("{}",value);
+    s.pad(size, '0', Alignment::Right, true)
+}
diff --git a/src/codec/echo/mod.rs b/src/codec/echo/mod.rs
index baceb0b..7faa85e 100644
--- a/src/codec/echo/mod.rs
+++ b/src/codec/echo/mod.rs
@@ -138,7 +138,24 @@ fn extract_workload(workload: &BTreeMap<String, Value>) -> CResult<BenchmarkWork
 
         let gen = Box::new(EchoGen { value: param });
 
-        Ok(BenchmarkWorkload::new(name, rate as usize, gen))
+        let amplitude = workload
+            .get("amplitude")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(0);
+
+        let period = workload
+            .get("period")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(1);
+
+        let phase = workload
+            .get("phase")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(0);
+
+        let sinus_parameters = SinusParametersWorkload::new(amplitude, period, phase);
+
+        Ok(BenchmarkWorkload::new(name, rate as usize, gen, sinus_parameters))
     } else {
         Err("malformed config: 'parameter' must be an array".to_owned())
     }
diff --git a/src/codec/memcache/mod.rs b/src/codec/memcache/mod.rs
index b7bfecc..580342c 100644
--- a/src/codec/memcache/mod.rs
+++ b/src/codec/memcache/mod.rs
@@ -304,7 +304,24 @@ fn extract_workload(i: usize, workload: &BTreeMap<String, Value>) -> CResult<Ben
             _ => return Err(format!("invalid command: {}", method)),
         };
 
-        Ok(BenchmarkWorkload::new(name, rate as usize, Box::new(cmd)))
+        let amplitude = workload
+            .get("amplitude")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(0);
+
+        let period = workload
+            .get("period")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(1);
+
+        let phase = workload
+            .get("phase")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(0);
+
+        let sinus_parameters = SinusParametersWorkload::new(amplitude, period, phase);
+
+        Ok(BenchmarkWorkload::new(name, rate as usize, Box::new(cmd), sinus_parameters))
     } else {
         Err("malformed config: 'parameter' must be an array".to_owned())
     }
diff --git a/src/codec/ping/mod.rs b/src/codec/ping/mod.rs
index ce6889a..6a0f675 100644
--- a/src/codec/ping/mod.rs
+++ b/src/codec/ping/mod.rs
@@ -17,7 +17,7 @@ mod gen;
 mod parse;
 
 use cfgtypes::{BenchmarkWorkload, CResult, ParsedResponse, ProtocolConfig, ProtocolGen,
-               ProtocolParse, ProtocolParseFactory};
+               ProtocolParse, ProtocolParseFactory, SinusParametersWorkload};
 use std::collections::BTreeMap;
 use std::str;
 use std::sync::Arc;
@@ -97,5 +97,22 @@ fn extract_workload(workload: &BTreeMap<String, Value>) -> CResult<BenchmarkWork
         .unwrap_or("ping")
         .to_owned();
 
-    Ok(BenchmarkWorkload::new(name, rate as usize, Box::new(Ping)))
+    let amplitude = workload
+        .get("amplitude")
+        .and_then(|k| k.as_integer())
+        .unwrap_or(0);
+
+    let period = workload
+        .get("period")
+        .and_then(|k| k.as_integer())
+        .unwrap_or(1);
+
+    let phase = workload
+        .get("phase")
+        .and_then(|k| k.as_integer())
+        .unwrap_or(0);
+
+    let sinus_parameters = SinusParametersWorkload::new(amplitude, period, phase);
+
+    Ok(BenchmarkWorkload::new(name, rate as usize, Box::new(Ping), sinus_parameters))
 }
diff --git a/src/codec/redis_inline/mod.rs b/src/codec/redis_inline/mod.rs
index 60587de..56100c1 100644
--- a/src/codec/redis_inline/mod.rs
+++ b/src/codec/redis_inline/mod.rs
@@ -18,7 +18,7 @@ mod parse;
 
 use cfgtypes;
 use cfgtypes::{BenchmarkWorkload, CResult, Parameter, ParsedResponse, ProtocolConfig, ProtocolGen,
-               ProtocolParse, ProtocolParseFactory, Ptype};
+               ProtocolParse, ProtocolParseFactory, Ptype, SinusParametersWorkload};
 use cfgtypes::tools;
 use getopts::Matches;
 use std::collections::BTreeMap;
@@ -266,7 +266,24 @@ fn extract_workload(workload: &BTreeMap<String, Value>) -> CResult<BenchmarkWork
             _ => return Err(format!("invalid command: {}", method)),
         };
 
-        Ok(BenchmarkWorkload::new(name, rate as usize, Box::new(cmd)))
+        let amplitude = workload
+            .get("amplitude")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(0);
+
+        let period = workload
+            .get("period")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(1);
+
+        let phase = workload
+            .get("phase")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(0);
+
+        let sinus_parameters = SinusParametersWorkload::new(amplitude, period, phase);
+
+        Ok(BenchmarkWorkload::new(name, rate as usize, Box::new(cmd), sinus_parameters))
     } else {
         Err("malformed config: 'parameter' must be an array".to_owned())
     }
diff --git a/src/codec/redis_resp/mod.rs b/src/codec/redis_resp/mod.rs
index 60587de..56100c1 100644
--- a/src/codec/redis_resp/mod.rs
+++ b/src/codec/redis_resp/mod.rs
@@ -18,7 +18,7 @@ mod parse;
 
 use cfgtypes;
 use cfgtypes::{BenchmarkWorkload, CResult, Parameter, ParsedResponse, ProtocolConfig, ProtocolGen,
-               ProtocolParse, ProtocolParseFactory, Ptype};
+               ProtocolParse, ProtocolParseFactory, Ptype, SinusParametersWorkload};
 use cfgtypes::tools;
 use getopts::Matches;
 use std::collections::BTreeMap;
@@ -266,7 +266,24 @@ fn extract_workload(workload: &BTreeMap<String, Value>) -> CResult<BenchmarkWork
             _ => return Err(format!("invalid command: {}", method)),
         };
 
-        Ok(BenchmarkWorkload::new(name, rate as usize, Box::new(cmd)))
+        let amplitude = workload
+            .get("amplitude")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(0);
+
+        let period = workload
+            .get("period")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(1);
+
+        let phase = workload
+            .get("phase")
+            .and_then(|k| k.as_integer())
+            .unwrap_or(0);
+
+        let sinus_parameters = SinusParametersWorkload::new(amplitude, period, phase);
+
+        Ok(BenchmarkWorkload::new(name, rate as usize, Box::new(cmd), sinus_parameters))
     } else {
         Err("malformed config: 'parameter' must be an array".to_owned())
     }
diff --git a/src/codec/thrift/config.rs b/src/codec/thrift/config.rs
index 5c81714..2f77f3b 100644
--- a/src/codec/thrift/config.rs
+++ b/src/codec/thrift/config.rs
@@ -18,7 +18,7 @@ use super::{Parameter, Tvalue};
 use super::gen;
 use super::parse;
 use cfgtypes::{BenchmarkWorkload, CResult, ParsedResponse, ProtocolConfig, ProtocolGen,
-               ProtocolParse, ProtocolParseFactory, Style, tools};
+               ProtocolParse, ProtocolParseFactory, SinusParametersWorkload, Style, tools};
 use cfgtypes::Value;
 use std::collections::BTreeMap;
 use std::sync::Arc;
@@ -122,7 +122,24 @@ fn extract_workload(workload: &BTreeMap<String, Value>) -> CResult<BenchmarkWork
         parameters: ps,
     });
 
-    Ok(BenchmarkWorkload::new(name, rate as usize, cmd))
+    let amplitude = workload
+        .get("amplitude")
+        .and_then(|k| k.as_integer())
+        .unwrap_or(0);
+
+    let period = workload
+        .get("period")
+        .and_then(|k| k.as_integer())
+        .unwrap_or(1);
+
+    let phase = workload
+        .get("phase")
+        .and_then(|k| k.as_integer())
+        .unwrap_or(0);
+
+    let sinus_parameters = SinusParametersWorkload::new(amplitude, period, phase);
+
+    Ok(BenchmarkWorkload::new(name, rate as usize, cmd, sinus_parameters))
 }
 
 fn extract_parameter(i: usize, parameter: &BTreeMap<String, Value>) -> CResult<Parameter> {
diff --git a/src/main.rs b/src/main.rs
index a994985..b1538df 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -26,10 +26,17 @@ extern crate bytes;
 extern crate byteorder;
 extern crate crc;
 extern crate getopts;
+extern crate fnv;
+extern crate histogram;
+extern crate hyper;
+#[macro_use]
+extern crate lazy_static;
 extern crate log_panics;
 extern crate mio;
 extern crate mpmc;
 extern crate pad;
+#[macro_use]
+extern crate prometheus;
 extern crate time;
 extern crate rand;
 extern crate ratelimit;
@@ -46,6 +53,7 @@ mod options;
 mod stats;
 mod codec;
 mod request;
+mod prometheusserver;
 
 use client::Client;
 use client::net::InternetProtocol;
diff --git a/src/prometheusserver.rs b/src/prometheusserver.rs
new file mode 100644
index 0000000..6d58d66
--- /dev/null
+++ b/src/prometheusserver.rs
@@ -0,0 +1,115 @@
+extern crate hyper;
+
+use hyper::{Body, Response, Request, Server};
+use hyper::rt::Future;
+use hyper::service::service_fn_ok;
+use lazy_static::*;
+use prometheus::{Counter, Encoder, Gauge, Histogram, HistogramVec, TextEncoder, Registry, push_metrics};
+use std::thread;
+use std::sync::{Arc, Mutex};
+use std::net::SocketAddr;
+
+lazy_static! {
+    static ref HTTP_COUNTER: Counter = register_counter!(opts!(
+        "example_http_requests_total",
+        "Total number of HTTP requests made.",
+        labels!{"handler" => "all",}
+    )).unwrap();
+    static ref HTTP_BODY_GAUGE: Gauge = register_gauge!(opts!(
+        "example_http_response_size_bytes",
+        "The HTTP response sizes in bytes.",
+        labels!{"handler" => "all",}
+    )).unwrap();
+    static ref HTTP_REQ_HISTOGRAM: HistogramVec = register_histogram_vec!(
+        "example_http_request_duration_seconds",
+        "The HTTP request latencies in seconds.",
+        &["handler"]
+    ).unwrap();
+    static ref PUSH_COUNTER: Counter = register_counter!(
+        "example_push_total",
+        "Total number of prometheus client pushed."
+    ).unwrap();
+    static ref PUSH_REQ_HISTOGRAM: Histogram = register_histogram!(
+        "example_push_request_duration_seconds",
+        "The push request latencies in seconds."
+    ).unwrap();
+}
+
+pub struct PrometheusServer {
+    r: Registry,
+    prepared_metric: Arc<Mutex<String>>,
+    addres: SocketAddr,
+}
+
+fn service(_req: Request<Body>, r: &Registry, data: &Arc<Mutex<String>>) -> Response<Body> {
+    HTTP_COUNTER.inc();
+    let timer = HTTP_REQ_HISTOGRAM.with_label_values(&["all"]).start_timer();
+
+    // Gather the metrics.
+    let mut buffer = vec![];
+    let encoder = TextEncoder::new();
+    let metric_familys = r.gather();
+    encoder.encode(&metric_familys, &mut buffer).unwrap();
+
+    timer.observe_duration();
+    HTTP_BODY_GAUGE.set(buffer.len() as f64);
+
+    let prepare_metric = data.lock().unwrap().to_string().to_owned();
+    let mut body = String::from_utf8(buffer).unwrap().to_owned();
+    body.push_str(&prepare_metric);
+
+    Response::new(Body::from(body))
+}
+
+
+impl PrometheusServer {
+    pub fn new() -> PrometheusServer {
+        PrometheusServer {
+            r: Registry::new(),
+            prepared_metric: Arc::new(Mutex::new(String::new())),
+            addres: ([127, 0, 0, 1], 9898).into(),
+        }
+    }
+
+    pub fn start(&self) {
+        let r = self.r.clone();
+        let prepared_metric =  Arc::clone(&self.prepared_metric);
+        let server = Server::bind(&self.addres)
+            .serve(move|| {
+                let r = r.clone();
+                let prepared_metric =  Arc::clone(&prepared_metric);
+                service_fn_ok(move|_req| {
+                    service(_req, &r, &prepared_metric)
+                })
+            })
+            .map_err(|e| eprintln!("server error: {}", e));
+
+        thread::spawn(|| {
+            hyper::rt::run(server);
+        });
+    }
+
+    #[cfg(not(feature = "push"))]
+    pub fn deliver_metrics(&mut self, metric: String) {
+        self.prepared_metric.lock().unwrap().clear();
+        self.prepared_metric.lock().unwrap().push_str(metric.as_str());
+    }
+
+    #[cfg(feature = "push")]
+    pub fn deliver_metrics(&self, metric: String) {
+        let address = "127.0.0.1:9091".to_owned();
+
+        PUSH_COUNTER.inc();
+        let metric_familys = self.r.gather();
+        let _timer = PUSH_REQ_HISTOGRAM.start_timer();
+
+        push_metrics(
+            "example_push",
+            labels!{"instance".to_owned() => "rpc-perf".to_owned(),},
+            &address,
+            metric_familys,
+        ).unwrap();
+    }
+}
+
+
diff --git a/src/request/workload.rs b/src/request/workload.rs
index 1195bbd..6bff660 100644
--- a/src/request/workload.rs
+++ b/src/request/workload.rs
@@ -17,7 +17,7 @@ pub const BUCKET_SIZE: usize = 10_000;
 
 use cfgtypes;
 
-use cfgtypes::ProtocolGen;
+use cfgtypes::{ProtocolGen, SinusParametersWorkload};
 use common::stats::Stat;
 use mpmc::Queue;
 use ratelimit;
@@ -46,6 +46,7 @@ pub fn launch_workloads(
             work_queue.to_vec(),
             stats.clone(),
             clocksource.clone(),
+            Some(w.sinus_parameters),
         ).unwrap();
 
         let _ = thread::Builder::new()
@@ -72,14 +73,26 @@ impl Workload {
         queue: Vec<Queue<Vec<u8>>>,
         stats: Sender<Stat>,
         clocksource: Clocksource,
+        sinus_parameters: Option<SinusParametersWorkload>,
     ) -> Result<Workload, &'static str> {
         let mut ratelimit = None;
+        let mut amplitude= 1;
+        let mut period = 1;
+        let mut phase = 1;
+        if let Some(r) = sinus_parameters {
+            amplitude = r.amplitude;
+            period = r.period;
+            phase = r.phase;
+        }
         if let Some(r) = rate {
             if r > 0 {
                 ratelimit = Some(
                     ratelimit::Builder::new()
                         .frequency(r as u32)
                         .capacity(BUCKET_SIZE as u32)
+                        .amplitude(amplitude)
+                        .phase(phase)
+                        .period(period)
                         .build(),
                 );
             }
diff --git a/src/stats.rs b/src/stats.rs
index 2b7fd8d..574c817 100644
--- a/src/stats.rs
+++ b/src/stats.rs
@@ -16,6 +16,103 @@
 use common::*;
 use request::BenchmarkConfig;
 use tic::{Interest, Meters, Percentile, Receiver};
+use prometheusserver::PrometheusServer;
+use std::collections::HashMap;
+use histogram::{Bucket, Histogram};
+use std::collections::hash_map::Entry;
+use std::cmp::Ordering;
+use std::hash::BuildHasherDefault;
+use fnv::FnvHasher;
+
+
+#[derive(Clone, Copy, Debug, Eq)]
+pub struct BucketTotal {
+    id: u64,
+    pub count: u64,
+    value: u64,
+    width: u64,
+}
+//
+//impl Copy for BucketTotal {
+//}
+//
+//impl Clone for BucketTotal {
+//    fn clone(&self) -> BucketTotal {
+//        *self
+//    }
+//}
+
+impl Ord for BucketTotal {
+    fn cmp(&self, other: &BucketTotal) -> Ordering {
+        self.id.cmp(&other.id)
+    }
+}
+
+impl PartialOrd for BucketTotal {
+    fn partial_cmp(&self, other: &BucketTotal) -> Option<Ordering> {
+        Some(self.cmp(other))
+    }
+}
+
+impl PartialEq for BucketTotal {
+    fn eq(&self, other: &BucketTotal) -> bool {
+        self.id == other.id
+    }
+}
+
+//impl BucketTotal {
+//    /// return the sample value for the bucket
+//    ///
+//    /// # Example
+//    /// ```
+//    /// # use histogram::Histogram;
+//    /// let mut h = Histogram::new();
+//    /// let b = h.into_iter().next().unwrap();
+//    /// assert_eq!(b.value(), 0);
+//    /// ```
+//    pub fn value(self) -> u64 {
+//        self.value
+//    }
+//
+//    /// return the sample counts for the bucket
+//    ///
+//    /// # Example
+//    /// ```
+//    /// # use histogram::Histogram;
+//    /// let h = Histogram::new();
+//    /// let b = h.into_iter().next().unwrap();
+//    /// assert_eq!(b.count(), 0);
+//    /// ```
+//    pub fn count(self) -> u64 {
+//        self.count
+//    }
+//
+//    /// return the bucket id
+//    ///
+//    /// # Example
+//    /// ```
+//    /// # use histogram::Histogram;
+//    /// let h = Histogram::new();
+//    /// let b = h.into_iter().next().unwrap();
+//    /// assert_eq!(b.id(), 0);
+//    /// ```
+//    pub fn id(self) -> u64 {
+//        self.id
+//    }
+//
+//    /// return the width of the bucket
+//    ///
+//    /// # Example
+//    /// ```
+//    /// # use histogram::Histogram;
+//    /// let h = Histogram::new();
+//    /// let b = h.into_iter().next().unwrap();
+//    /// assert_eq!(b.width(), 1);
+//    /// ```
+//    pub fn width(self) -> u64 {
+//        self.width
+//    }
+//}
 
 pub fn stats_receiver_init(
     config: &BenchmarkConfig,
@@ -27,7 +124,8 @@ pub fn stats_receiver_init(
         .batch_size(1024)
         .capacity(4096)
         .duration(config.duration())
-        .windows(config.windows());
+        .windows(config.windows())
+        .histogram_config(1_000_000_000, 1);
 
     if let Some(addr) = listen {
         stats_config = stats_config.http_listen(addr);
@@ -86,6 +184,10 @@ pub fn meters_delta(t0: &Meters<Stat>, t1: &Meters<Stat>, stat: &Stat) -> u64 {
 
 pub fn run(mut receiver: Receiver<Stat>, windows: usize, infinite: bool) {
 
+    let mut promeheus_server = PrometheusServer::new();
+    promeheus_server.start();
+    let mut total_histogram: HashMap<Stat,  HashMap<i32, BucketTotal>> = HashMap::new();
+
     let mut window = 0;
     let mut warmup = true;
     let mut next_window = window + windows;
@@ -103,6 +205,9 @@ pub fn run(mut receiver: Receiver<Stat>, windows: usize, infinite: bool) {
         let t1 = clocksource.counter();
         let m1 = receiver.clone_meters();
 
+        let histograms: HashMap<Stat, Histogram, BuildHasherDefault<FnvHasher>> = receiver.get_reciver_histogram().try_recv().unwrap();
+        let mut text_respond: String = String::new();
+
         if warmup {
             info!("-----");
             info!("Warmup complete");
@@ -176,6 +281,12 @@ pub fn run(mut receiver: Receiver<Stat>, windows: usize, infinite: bool) {
                 2,
                 hit_rate
             );
+
+
+            text_respond += &histograms_prometheus(histograms, &mut total_histogram);
+            text_respond += &percentiles_prometheus(&m1, &Stat::ResponseOk).to_string();
+            promeheus_server.deliver_metrics(text_respond);
+
             display_percentiles(&m1, &Stat::ResponseOk, "Response OK");
         }
 
@@ -195,6 +306,58 @@ pub fn run(mut receiver: Receiver<Stat>, windows: usize, infinite: bool) {
     }
 }
 
+fn histograms_prometheus(histograms: HashMap<Stat, Histogram, BuildHasherDefault<FnvHasher>>, total_histogram: &mut HashMap<Stat, HashMap<i32, BucketTotal>>) -> String {
+    let mut text_respond: String = String::new();
+    for (key, histogram) in histograms.iter() {
+        text_respond += &type_histogram_prometheus(key.to_string());
+        let (text_respond_buckets, sum_one_respond, max_value) = buckets_histogram_prometheus(key, histogram, total_histogram);
+        text_respond += &text_respond_buckets.to_string();
+        text_respond += &sum_count_histogram_prometheus(key.to_string(), max_value, sum_one_respond);
+    }
+    text_respond
+}
+
+fn buckets_histogram_prometheus(key: &Stat, histogram: &Histogram, total_histogram: &mut HashMap<Stat,  HashMap<i32, BucketTotal>>) -> (String, u64, u64) {
+    let mut text_respond: String = String::from("");
+    let mut sum_one_respond: u64 = 0;
+    let mut max_value: u64 = 0;
+    for bucket in histogram.into_iter() {
+        sum_one_respond += bucket.count();
+        match total_histogram.entry(key.clone()) {
+            Entry::Occupied(p) => {
+                text_respond += &merge_bucket_to_total_histogram(p.into_mut(), bucket, key, &mut max_value, &mut sum_one_respond);
+            },
+            Entry::Vacant(d) => {
+                d.insert(HashMap::new());
+            },
+        }
+    }
+    (text_respond.to_string(), sum_one_respond, max_value)
+}
+
+fn merge_bucket_to_total_histogram(p: &mut HashMap<i32, BucketTotal>, bucket: Bucket, key: &Stat, max_value: &mut u64, sum_one_respond: &mut u64) -> String {
+    let mut text_respond: String = String::new();
+    match p.entry(bucket.id() as i32) {
+        Entry::Occupied(c) => {
+            let cc = *c.get();
+            //let ccc = cc.copy();
+            c.into_mut().count += *sum_one_respond;
+            *max_value = cc.count;
+            if bucket.count() > 0 {
+                text_respond += &bucket_histogram_prometheus(key.to_string(), cc);
+            }
+        },
+        Entry::Vacant(v) => {
+            let new_bucket = BucketTotal { id: bucket.id(), count: *sum_one_respond, value: bucket.value(), width: bucket.width() };
+            v.insert(new_bucket);
+            if bucket.count() > 0 {
+                text_respond += &bucket_histogram_prometheus(key.to_string(), new_bucket);
+            }
+        },
+    }
+    text_respond
+}
+
 fn display_percentiles(meters: &Meters<Stat>, stat: &Stat, label: &str) {
     info!("Percentiles: {} (us): min: {} p50: {} p90: {} p99: {} p999: {} p9999: {} max: {}",
                     label,
@@ -212,5 +375,61 @@ fn display_percentiles(meters: &Meters<Stat>, stat: &Stat, label: &str) {
                         Percentile("p9999".to_owned(), 99.99)).unwrap_or(&0) / 1000,
                     meters.percentile(stat,
                         Percentile("max".to_owned(), 100.0)).unwrap_or(&0) / 1000,
-                );
+                        );
+}
+
+fn type_histogram_prometheus(metric_name: String) -> String {
+    let help_text = "rpc-perf metric";
+    format!("\
+        # HELP {0} {1}\n\
+        # TYPE {0} summary\n\
+        ",
+            metric_name,
+            help_text
+    ).to_string()
+}
+
+fn bucket_histogram_prometheus(metric_name: String, bucket: BucketTotal) -> String {
+    format!("{0}_bucket{{le=\"{1}\"}} {2}\n", metric_name, bucket.value, bucket.count).to_string()
+}
+
+fn sum_count_histogram_prometheus(metric_name: String, count: u64, sum: u64) -> String {
+    format!("\
+    {0}_bucket{{le=\"+Inf\"}} {1}\n\
+    {0}_sum {2}\n\
+    {0}_count {1}\n\
+    ",
+            metric_name,
+            count,
+            sum
+    ).to_string()
+}
+
+fn percentiles_prometheus(meters: &Meters<Stat>, stat: &Stat) -> String {
+
+    let metric_name = "wydajnosc";
+    let help_text = "The total number of HTTP requests.";
+
+    format!("\
+        # HELP {0} {1}\n\
+        # TYPE {0} summary\n\
+        {0}{{quantile=\"0.5\"}} {2}\n\
+        {0}{{quantile=\"0.9\"}} {3}\n\
+        {0}{{quantile=\"0.99\"}} {4}\n\
+        {0}{{quantile=\"0.999\"}} {5}\n\
+        {0}{{quantile=\"0.9999\"}} {6}\n\
+        {0}_sum {7}\n\
+        {0}_count {8:?}\n\
+        ",
+            metric_name,
+            help_text,
+            meters.percentile(stat, Percentile("p50".to_owned(), 50.0)).unwrap_or(&0) / 1000,
+            meters.percentile(stat, Percentile("p90".to_owned(), 90.0)).unwrap_or(&0) / 1000,
+            meters.percentile(stat, Percentile("p99".to_owned(), 99.0)).unwrap_or(&0) / 1000,
+            meters.percentile(stat, Percentile("p999".to_owned(), 99.9)).unwrap_or(&0) / 1000,
+            meters.percentile(stat, Percentile("p9999".to_owned(), 99.99)).unwrap_or(&0) / 1000,
+            meters.percentile(stat, Percentile("max".to_owned(), 100.0)).unwrap_or(&0) / 1000,
+            //meters.
+            meters.count(stat).unwrap(),
+    ).to_string()
 }
diff --git a/tic/.gitignore b/tic/.gitignore
new file mode 100644
index 0000000..7c76538
--- /dev/null
+++ b/tic/.gitignore
@@ -0,0 +1,5 @@
+target
+Cargo.lock
+*.png
+*.txt
+*.bk
diff --git a/tic/.travis.yml b/tic/.travis.yml
new file mode 100644
index 0000000..143735c
--- /dev/null
+++ b/tic/.travis.yml
@@ -0,0 +1,31 @@
+language: rust
+rust:
+- stable
+- beta
+- nightly
+os: linux
+env: TYPE=default RUST_BACKTRACE=1
+matrix:
+  include:
+    - os: linux
+      rust: nightly
+      env: TYPE=features RUST_BACKTRACE=1
+      script:
+        - cargo test --features asm
+        - cargo build --features asm
+        - cargo test --release --features asm
+        - cargo build --release --features asm
+    - os: linux
+      rust: stable
+      env: TYPE=rustfmt RUST_BACKTRACE=1
+      script:
+        - cargo install rustfmt || cargo fmt -- --version || cargo install -f rustfmt
+        - cargo fmt -- --write-mode=diff
+    - os: linux
+      rust: nightly
+      env: TYPE=clippy RUST_BACKTRACE=1
+      script:
+        - cargo install clippy || cargo clippy -- --version || cargo install -f clippy
+        - cargo clippy
+  allow_failures:
+    - env: TYPE=clippy RUST_BACKTRACE=1
\ No newline at end of file
diff --git a/tic/Cargo.toml b/tic/Cargo.toml
new file mode 100644
index 0000000..f551e4d
--- /dev/null
+++ b/tic/Cargo.toml
@@ -0,0 +1,39 @@
+[package]
+name = "tic"
+version = "0.2.4"
+authors = ["Brian Martin <brayniac@gmail.com>"]
+
+license = "MIT OR Apache-2.0"
+
+description = "a high-performance stats library focused on rates and latencies from timestamped events"
+
+homepage = "https://github.com/brayniac/tic"
+documentation = "https://docs.rs/tic"
+repository = "https://github.com/brayniac/tic"
+
+readme = "README.md"
+
+keywords = ["stats", "metrics", "telemetry", "interval"]
+
+[dependencies]
+allan = "0.2.2"
+clocksource = "0.2.2"
+fnv = "1.0.5"
+getopts = "0.2.14"
+heatmap = "0.6.5"
+histogram = "0.6.6"
+log = "0.3.8"
+mio = "0.6.9"
+mpmc = "0.1.2"
+tiny_http = "0.5.8"
+time = "0.1.37"
+waterfall = "0.7.0"
+
+[dev-dependencies]
+rand = "0.3.16"
+
+[features]
+default = []
+benchmark = []
+rdtsc = ["clocksource/rdtsc"]
+asm = ["rdtsc"]
diff --git a/tic/LICENSE-APACHE b/tic/LICENSE-APACHE
new file mode 100644
index 0000000..6a81174
--- /dev/null
+++ b/tic/LICENSE-APACHE
@@ -0,0 +1,202 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2016 Brian Martin
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
+
diff --git a/tic/LICENSE-MIT b/tic/LICENSE-MIT
new file mode 100644
index 0000000..e01eb3f
--- /dev/null
+++ b/tic/LICENSE-MIT
@@ -0,0 +1,19 @@
+Copyright (c) 2016 Brian Martin
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/tic/README.md b/tic/README.md
new file mode 100644
index 0000000..590a1de
--- /dev/null
+++ b/tic/README.md
@@ -0,0 +1,52 @@
+# tic - time interval counts and statistics
+a high-performance stats library focused on rates and latencies from timestamped events
+
+[![travis-badge][]][travis] [![downloads-badge][] ![release-badge][]][crate] [![license-badge][]](#license)
+
+[travis-badge]: https://img.shields.io/travis/brayniac/tic/master.svg
+[downloads-badge]: https://img.shields.io/crates/d/tic.svg
+[release-badge]: https://img.shields.io/crates/v/tic.svg
+[license-badge]: https://img.shields.io/crates/l/tic.svg
+[travis]: https://travis-ci.org/brayniac/tic
+[crate]: https://crates.io/crates/tic
+[Cargo]: https://github.com/rust-lang/cargo
+
+## Usage
+
+The API documentation of this library can be found at
+[docs.rs/tic](https://docs.rs/tic/)
+
+## Performance and Example
+
+Performance is a top-priority. To test performance, we use tic to benchmark itself.
+
+```shell
+cargo run --release --example benchmark -- --help
+cargo run --release --example benchmark
+```
+
+## Features
+
+* high throughput - millions of samples per second
+* latched histogram - for analyzing the full distribution of sample lengths
+* heatmaps - to generate distribution traces and waterfalls
+* meters - to expose readings for client usage
+* http metrics - simple metrics on http for scraping and monitoring, Prometheus compatible
+* generic - channel type is generic, and used to label the type of sample
+* flexible - per channel stats are accessible by registering appropriate `Interest`s
+
+## License
+
+Licensed under either of
+
+ * Apache License, Version 2.0, ([LICENSE-APACHE](LICENSE-APACHE) or http://www.apache.org/licenses/LICENSE-2.0)
+ * MIT license ([LICENSE-MIT](LICENSE-MIT) or http://opensource.org/licenses/MIT)
+
+at your option.
+
+### Contribution
+
+Unless you explicitly state otherwise, any contribution intentionally
+submitted for inclusion in the work by you, as defined in the Apache-2.0
+license, shall be dual licensed as above, without any additional terms or
+conditions.
diff --git a/tic/examples/allan.rs b/tic/examples/allan.rs
new file mode 100644
index 0000000..b16e8b8
--- /dev/null
+++ b/tic/examples/allan.rs
@@ -0,0 +1,220 @@
+#![cfg_attr(feature = "cargo-clippy", deny(warnings))]
+#![allow(unknown_lints)]
+#![allow(many_single_char_names)]
+extern crate getopts;
+#[macro_use]
+extern crate log;
+extern crate tic;
+extern crate time;
+
+use getopts::Options;
+use log::{LogLevel, LogLevelFilter, LogMetadata, LogRecord};
+use std::{env, fmt, thread};
+use tic::{Clocksource, Interest, Percentile, Receiver, Sample, Sender};
+
+const SECOND: u64 = 1_000_000_000;
+
+#[derive(Clone, PartialEq, Eq, Hash)]
+pub enum Metric {
+    Ok,
+}
+
+impl fmt::Display for Metric {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        match *self {
+            Metric::Ok => write!(f, "ok"),
+        }
+    }
+}
+
+struct Generator {
+    stats: Sender<Metric>,
+    clocksource: Clocksource,
+}
+
+impl Generator {
+    fn new(stats: Sender<Metric>, clocksource: Clocksource) -> Generator {
+        Generator {
+            stats: stats,
+            clocksource: clocksource,
+        }
+    }
+
+    fn run(&mut self) {
+        let mut t1 = time::precise_time_ns() + SECOND;
+        loop {
+            let t = time::precise_time_ns();
+            if t > t1 {
+                let t2 = self.clocksource.time();
+                trace!("sample: ref: {} tsc: {}", t, t2);
+                self.stats.send(Sample::new(t, t2, Metric::Ok)).unwrap();
+                t1 += SECOND;
+            }
+        }
+    }
+}
+
+pub struct SimpleLogger;
+
+impl log::Log for SimpleLogger {
+    fn enabled(&self, metadata: &LogMetadata) -> bool {
+        metadata.level() <= LogLevel::Trace
+    }
+
+    fn log(&self, record: &LogRecord) {
+        if self.enabled(record.metadata()) {
+            println!(
+                "{} {:<5} [{}] {}",
+                time::strftime("%Y-%m-%d %H:%M:%S", &time::now()).unwrap(),
+                record.level().to_string(),
+                "allan",
+                record.args()
+            );
+        }
+    }
+}
+
+fn set_log_level(level: usize) {
+    let log_filter;
+    match level {
+        0 => {
+            log_filter = LogLevelFilter::Info;
+        }
+        1 => {
+            log_filter = LogLevelFilter::Debug;
+        }
+        _ => {
+            log_filter = LogLevelFilter::Trace;
+        }
+    }
+    let _ = log::set_logger(|max_log_level| {
+        max_log_level.set(log_filter);
+        Box::new(SimpleLogger)
+    });
+}
+
+fn print_usage(program: &str, opts: &Options) {
+    let brief = format!("Usage: {} [options]", program);
+    print!("{}", opts.usage(&brief));
+}
+
+pub fn opts() -> Options {
+    let mut opts = Options::new();
+
+    opts.optopt("w", "windows", "number of integration windows", "INTEGER");
+    opts.optflag("h", "help", "print this help menu");
+
+    opts
+}
+
+fn main() {
+    let args: Vec<String> = env::args().collect();
+
+    let program = &args[0];
+
+    let opts = opts();
+
+    let matches = match opts.parse(&args[1..]) {
+        Ok(m) => m,
+        Err(f) => {
+            error!("Failed to parse command line args: {}", f);
+            return;
+        }
+    };
+
+    if matches.opt_present("help") {
+        print_usage(program, &opts);
+        return;
+    }
+    set_log_level(1);
+    info!("tic benchmark");
+
+    let windows = matches
+        .opt_str("windows")
+        .unwrap_or_else(|| "300".to_owned())
+        .parse()
+        .unwrap();
+    let duration = 1;
+    let capacity = 128;
+    let batch = 1;
+
+    // initialize a Receiver for the benchmark
+    let mut receiver = Receiver::configure()
+        .windows(windows)
+        .duration(duration)
+        .capacity(capacity)
+        .batch_size(batch)
+        .service(true)
+        .http_listen("localhost:42024".to_owned())
+        .build();
+
+    receiver.add_interest(Interest::Waterfall(
+        Metric::Ok,
+        "ok_waterfall.png".to_owned(),
+    ));
+    receiver.add_interest(Interest::Trace(Metric::Ok, "ok_trace.txt".to_owned()));
+    receiver.add_interest(Interest::Count(Metric::Ok));
+    receiver.add_interest(Interest::Percentile(Metric::Ok));
+    receiver.add_interest(Interest::AllanDeviation(Metric::Ok));
+
+    let sender = receiver.get_sender();
+    let clocksource = receiver.get_clocksource();
+
+    let s = sender.clone();
+    let c = clocksource.clone();
+
+    thread::spawn(move || { Generator::new(s, c).run(); });
+
+    let mut total = 0;
+
+    let windows = windows;
+    // we run the receiver manually so we can access the Meters
+    for _ in 0..windows {
+        let t0 = clocksource.time();
+        receiver.run_once();
+        let t1 = clocksource.time();
+        let m = receiver.clone_meters();
+        let mut c = 0;
+        if let Some(t) = m.count(&Metric::Ok) {
+            c = *t - total;
+            total = *t;
+        }
+        let r = c as f64 / ((t1 - t0) as f64 / 1_000_000_000.0);
+
+        info!("rate: {} samples per second", r);
+        info!(
+            "latency (ns): p50: {} p90: {} p999: {} p9999: {} max: {}",
+            m.percentile(&Metric::Ok, Percentile("p50".to_owned(), 50.0))
+                .unwrap_or(&0),
+            m.percentile(&Metric::Ok, Percentile("p90".to_owned(), 90.0))
+                .unwrap_or(&0),
+            m.percentile(&Metric::Ok, Percentile("p999".to_owned(), 99.9))
+                .unwrap_or(&0),
+            m.percentile(&Metric::Ok, Percentile("p9999".to_owned(), 99.99))
+                .unwrap_or(&0),
+            m.percentile(&Metric::Ok, Percentile("max".to_owned(), 100.0))
+                .unwrap_or(&0)
+        );
+        for t in 1..10 {
+            info!(
+                "ADEV:    t={}: {}",
+                t,
+                m.adev(Metric::Ok, t).unwrap_or(&0.0)
+            );
+        }
+        for t in 10..21 {
+            info!("ADEV:   t={}: {}", t, m.adev(Metric::Ok, t).unwrap_or(&0.0));
+        }
+        for t in 3..10 {
+            let t = t * 10;
+            info!("ADEV:   t={}: {}", t, m.adev(Metric::Ok, t).unwrap_or(&0.0));
+        }
+        for t in 1..4 {
+            let t = t * 100;
+            info!("ADEV:  t={}: {}", t, m.adev(Metric::Ok, t).unwrap_or(&0.0));
+        }
+    }
+    info!("saving files...");
+    receiver.save_files();
+    info!("saved");
+}
diff --git a/tic/examples/benchmark.rs b/tic/examples/benchmark.rs
new file mode 100644
index 0000000..41a11b2
--- /dev/null
+++ b/tic/examples/benchmark.rs
@@ -0,0 +1,228 @@
+#![cfg_attr(feature = "cargo-clippy", deny(warnings))]
+extern crate getopts;
+#[macro_use]
+extern crate log;
+extern crate tic;
+extern crate time;
+
+use getopts::Options;
+use log::{LogLevel, LogLevelFilter, LogMetadata, LogRecord};
+use std::env;
+use std::fmt;
+use std::thread;
+use tic::{Clocksource, Interest, Percentile, Receiver, Sample, Sender};
+
+#[derive(Clone, PartialEq, Eq, Hash)]
+pub enum Metric {
+    Ok,
+}
+
+impl fmt::Display for Metric {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        match *self {
+            Metric::Ok => write!(f, "ok"),
+        }
+    }
+}
+
+struct Generator {
+    stats: Sender<Metric>,
+    t0: Option<u64>,
+    clocksource: Clocksource,
+}
+
+impl Generator {
+    fn new(stats: Sender<Metric>, clocksource: Clocksource) -> Generator {
+        Generator {
+            stats: stats,
+            t0: None,
+            clocksource: clocksource,
+        }
+    }
+
+    fn run(&mut self) {
+        loop {
+            let t1 = self.clocksource.counter();
+            if let Some(t0) = self.t0 {
+                let _ = self.stats.send(Sample::new(t0, t1, Metric::Ok));
+            }
+            self.t0 = Some(t1);
+        }
+    }
+}
+
+pub struct SimpleLogger;
+
+impl log::Log for SimpleLogger {
+    fn enabled(&self, metadata: &LogMetadata) -> bool {
+        metadata.level() <= LogLevel::Trace
+    }
+
+    fn log(&self, record: &LogRecord) {
+        if self.enabled(record.metadata()) {
+            println!(
+                "{} {:<5} [{}] {}",
+                time::strftime("%Y-%m-%d %H:%M:%S", &time::now()).unwrap(),
+                record.level().to_string(),
+                "tic benchmark",
+                record.args()
+            );
+        }
+    }
+}
+
+fn set_log_level(level: usize) {
+    let log_filter;
+    match level {
+        0 => {
+            log_filter = LogLevelFilter::Info;
+        }
+        1 => {
+            log_filter = LogLevelFilter::Debug;
+        }
+        _ => {
+            log_filter = LogLevelFilter::Trace;
+        }
+    }
+    let _ = log::set_logger(|max_log_level| {
+        max_log_level.set(log_filter);
+        Box::new(SimpleLogger)
+    });
+}
+
+fn print_usage(program: &str, opts: &Options) {
+    let brief = format!("Usage: {} [options]", program);
+    print!("{}", opts.usage(&brief));
+}
+
+pub fn opts() -> Options {
+    let mut opts = Options::new();
+
+    opts.optopt("p", "producers", "number of producers", "INTEGER");
+    opts.optopt("w", "windows", "number of integration windows", "INTEGER");
+    opts.optopt("d", "duration", "length of integration window", "INTEGER");
+    opts.optopt("c", "capacity", "size of the mpmc queue", "INTEGER");
+    opts.optopt(
+        "b",
+        "batch",
+        "batch size of producer writes to queue",
+        "INTEGER",
+    );
+    opts.optflag("h", "help", "print this help menu");
+
+    opts
+}
+
+fn main() {
+    let args: Vec<String> = env::args().collect();
+
+    let program = &args[0];
+
+    let opts = opts();
+
+    let matches = match opts.parse(&args[1..]) {
+        Ok(m) => m,
+        Err(f) => {
+            error!("Failed to parse command line args: {}", f);
+            return;
+        }
+    };
+
+    if matches.opt_present("help") {
+        print_usage(program, &opts);
+        return;
+    }
+    set_log_level(1);
+    info!("tic benchmark");
+
+    let windows = matches
+        .opt_str("windows")
+        .unwrap_or_else(|| "60".to_owned())
+        .parse()
+        .unwrap();
+    let duration = matches
+        .opt_str("duration")
+        .unwrap_or_else(|| "1".to_owned())
+        .parse()
+        .unwrap();
+    let capacity = matches
+        .opt_str("capacity")
+        .unwrap_or_else(|| "10000".to_owned())
+        .parse()
+        .unwrap();
+    let batch = matches
+        .opt_str("batch")
+        .unwrap_or_else(|| "1".to_owned())
+        .parse()
+        .unwrap();
+    let producers = matches
+        .opt_str("producers")
+        .unwrap_or_else(|| "1".to_owned())
+        .parse()
+        .unwrap();
+
+    // initialize a Receiver for the benchmark
+    let mut receiver = Receiver::configure()
+        .windows(windows)
+        .duration(duration)
+        .capacity(capacity)
+        .batch_size(batch)
+        .http_listen("localhost:42024".to_owned())
+        .build();
+
+    receiver.add_interest(Interest::Waterfall(
+        Metric::Ok,
+        "ok_waterfall.png".to_owned(),
+    ));
+    receiver.add_interest(Interest::Trace(Metric::Ok, "ok_trace.txt".to_owned()));
+    receiver.add_interest(Interest::Count(Metric::Ok));
+    receiver.add_interest(Interest::Percentile(Metric::Ok));
+
+    let sender = receiver.get_sender();
+    let clocksource = receiver.get_clocksource();
+
+    info!("producers: {}", producers);
+    info!("batch size: {}", batch);
+    info!("capacity: {}", capacity);
+
+    for _ in 0..producers {
+        let s = sender.clone();
+        let c = clocksource.clone();
+        thread::spawn(move || { Generator::new(s, c).run(); });
+    }
+
+    let mut total = 0;
+
+    let windows = windows;
+    // we run the receiver manually so we can access the Meters
+    for _ in 0..windows {
+        let t0 = clocksource.time();
+        receiver.run_once();
+        let t1 = clocksource.time();
+        let m = receiver.clone_meters();
+        let mut c = 0;
+        if let Some(t) = m.count(&Metric::Ok) {
+            c = *t - total;
+            total = *t;
+        }
+        let r = c as f64 / ((t1 - t0) as f64 / 1_000_000_000.0);
+
+        info!("rate: {} samples per second", r);
+        info!(
+            "latency (ns): p50: {} p90: {} p999: {} p9999: {} max: {}",
+            m.percentile(&Metric::Ok, Percentile("p50".to_owned(), 50.0))
+                .unwrap_or(&0),
+            m.percentile(&Metric::Ok, Percentile("p90".to_owned(), 90.0))
+                .unwrap_or(&0),
+            m.percentile(&Metric::Ok, Percentile("p999".to_owned(), 99.9))
+                .unwrap_or(&0),
+            m.percentile(&Metric::Ok, Percentile("p9999".to_owned(), 99.99))
+                .unwrap_or(&0),
+            m.percentile(&Metric::Ok, Percentile("max".to_owned(), 100.0))
+                .unwrap_or(&0)
+        );
+    }
+    info!("saving files...");
+    receiver.save_files();
+    info!("saved");
+}
diff --git a/tic/rustfmt.toml b/tic/rustfmt.toml
new file mode 100644
index 0000000..0468aa5
--- /dev/null
+++ b/tic/rustfmt.toml
@@ -0,0 +1,2 @@
+reorder_imports = true
+reorder_imported_names = true
diff --git a/tic/src/common.rs b/tic/src/common.rs
new file mode 100644
index 0000000..743dbf9
--- /dev/null
+++ b/tic/src/common.rs
@@ -0,0 +1,49 @@
+#[derive(Clone, Eq, Hash, PartialEq)]
+/// an Interest registers a metric for reporting
+pub enum Interest<T> {
+    /// Calculate ADEV for the given metric
+    AllanDeviation(T),
+    /// Keep a counter for the given metric
+    Count(T),
+    /// Calculate latency percentiles for metric
+    Percentile(T),
+    /// Creates a trace file of the latency heatmap
+    Trace(T, String),
+    /// Generate a PNG plot of the latency heatmaps
+    Waterfall(T, String),
+}
+
+#[derive(Clone, Eq, Hash, PartialEq)]
+pub enum ControlMessage<T> {
+    AddInterest(Interest<T>),
+    RemoveInterest(Interest<T>),
+}
+
+#[derive(Clone)]
+/// a Percentile is the label plus floating point percentile representation
+pub struct Percentile(pub String, pub f64);
+
+// helper function to populate the default `Percentile`s to report
+pub fn default_percentiles() -> Vec<Percentile> {
+    let mut p = Vec::new();
+    p.push(Percentile("min".to_owned(), 0.0));
+    p.push(Percentile("p50".to_owned(), 50.0));
+    p.push(Percentile("p75".to_owned(), 75.0));
+    p.push(Percentile("p90".to_owned(), 90.0));
+    p.push(Percentile("p95".to_owned(), 95.0));
+    p.push(Percentile("p99".to_owned(), 99.0));
+    p.push(Percentile("p999".to_owned(), 99.9));
+    p.push(Percentile("p9999".to_owned(), 99.99));
+    p.push(Percentile("max".to_owned(), 100.0));
+    p
+}
+
+// helper function to populate the default `Taus`s to report
+// - All Taus from 1 to 300s inclusive
+pub fn default_taus() -> Vec<usize> {
+    let mut t = Vec::new();
+    for i in 1..301 {
+        t.push(i);
+    }
+    t
+}
diff --git a/tic/src/config.rs b/tic/src/config.rs
new file mode 100644
index 0000000..3ce0fd0
--- /dev/null
+++ b/tic/src/config.rs
@@ -0,0 +1,212 @@
+extern crate heatmap;
+extern crate histogram;
+
+use heatmap::Heatmap;
+use histogram::Histogram;
+use receiver::Receiver;
+use std::fmt::Display;
+use std::hash::Hash;
+use std::marker::PhantomData;
+use std::time::Duration;
+
+/// a configuration struct for customizing `Receiver`
+#[derive(Clone)]
+pub struct Config<T> {
+    resource_type: PhantomData<T>,
+    /// duration of a sampling interval (window) in seconds
+    /// typical values are 1 or 60 for secondly or minutely reporting
+    pub duration: usize,
+    /// the number of sampling intervals (windows) to aggregate in
+    /// heatmap and traces.
+    /// NOTE: The receiver will halt if service_mode is false and the
+    /// total number of windows have elapsed
+    pub windows: usize,
+    /// the capacity of the stats queue. Default: 256
+    pub capacity: usize,
+    /// the default batch size of a `Sender`. Default: 512
+    pub batch_size: usize,
+    /// set continuous-run mode. heatmaps and traces will generate
+    /// every N windows when this is set to true. If it is set to false,
+    /// the `Receiver` will halt after N windows
+    pub service_mode: bool,
+    /// set an optional delay between calls to poll
+    pub poll_delay: Option<Duration>,
+    /// enable the HTTP stats export on the given address
+    pub http_listen: Option<String>,
+    /// save a latency heatmap trace to the given file
+    pub trace_file: Option<String>,
+    /// save a waterfal png of the latency heatmap to the given file
+    pub waterfall_file: Option<String>,
+    /// the shared `Heatmap` configuration
+    pub heatmap_config: heatmap::Config,
+    /// the shared `Histogram` configuration
+    pub histogram_config: histogram::Config,
+}
+
+impl<T: Hash + Eq + Send + Display + Clone> Default for Config<T> {
+    fn default() -> Config<T> {
+        let heatmap_config = Heatmap::configure()
+            .slice_duration(1_000_000_000)
+            .precision(2);
+        let histogram_config = Histogram::configure()
+            .max_value(60 * 1_000_000_000)
+            .precision(4);
+        Config {
+            resource_type: PhantomData::<T>,
+            duration: 60,
+            windows: 60,
+            capacity: 256,
+            batch_size: 512,
+            service_mode: false,
+            poll_delay: None,
+            http_listen: None,
+            trace_file: None,
+            waterfall_file: None,
+            heatmap_config: heatmap_config,
+            histogram_config: histogram_config,
+        }
+    }
+}
+
+impl<T: Hash + Eq + Send + Display + Clone> Config<T> {
+    /// create a new tic Config with defaults
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// ```
+    pub fn new() -> Config<T> {
+        Default::default()
+    }
+
+    /// set integration window in seconds: default 60
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.duration(60); // set to 60 second integration window
+    /// ```
+    pub fn duration(mut self, duration: usize) -> Self {
+        self.duration = duration;
+        self.heatmap_config.num_slices(self.duration * self.windows);
+        self
+    }
+
+    /// set number of windows to collect: default 60
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.windows(60); // collect for 60 x duration and terminate
+    /// ```
+    pub fn windows(mut self, windows: usize) -> Self {
+        self.windows = windows;
+        self.heatmap_config.num_slices(self.duration * self.windows);
+        self
+    }
+
+    /// set capacity of the queue: default 256
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.capacity(256); // buffer for 256 batches of samples
+    /// ```
+    pub fn capacity(mut self, capacity: usize) -> Self {
+        self.capacity = capacity;
+        self
+    }
+
+    /// set batch size of the sender: default 512
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.batch_size(512); // batch 512 samples in one queue write
+    /// ```
+    pub fn batch_size(mut self, batch_size: usize) -> Self {
+        self.batch_size = batch_size;
+        self
+    }
+
+    /// set the http lister address
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.http_listen("0.0.0.0:42024".to_owned()); // listen on port 42024 on all interfaces
+    /// ```
+    pub fn http_listen(mut self, address: String) -> Self {
+        self.http_listen = Some(address);
+        self
+    }
+
+    /// set the heatmap trace file
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.trace_file("/tmp/heatmap.trace".to_owned()); // heatmap trace will write here
+    /// ```
+    pub fn trace_file(mut self, path: String) -> Self {
+        self.trace_file = Some(path);
+        self
+    }
+
+    /// set the heatmap trace file
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.waterfall_file("/tmp/waterfall.png".to_owned()); // waterfall png will render here
+    /// ```
+    pub fn waterfall_file(mut self, path: String) -> Self {
+        self.waterfall_file = Some(path);
+        self
+    }
+
+    /// set the poll delay
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// # use std::time::Duration;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.poll_delay(Some(Duration::new(0, 100_000)));
+    pub fn poll_delay(mut self, delay: Option<Duration>) -> Self {
+        self.poll_delay = delay;
+        self
+    }
+
+    /// set receiver to continuous run mode aka service mode
+    ///
+    /// # Example
+    /// ```
+    /// # use tic::Receiver;
+    /// let mut c = Receiver::<usize>::configure();
+    /// c.service(true);
+    pub fn service(mut self, enabled: bool) -> Self {
+        self.service_mode = enabled;
+        self
+    }
+
+    pub fn histogram_config(mut self, max_value: u64, precision: u32) -> Self {
+        self.histogram_config = Histogram::configure()
+            .max_value( max_value)
+            .precision(precision);
+        self
+    }
+
+    /// Build a new Receiver based on the current configuration
+    pub fn build(self) -> Receiver<T> {
+        Receiver::configured(self)
+    }
+}
diff --git a/tic/src/data/allans.rs b/tic/src/data/allans.rs
new file mode 100644
index 0000000..c21ee50
--- /dev/null
+++ b/tic/src/data/allans.rs
@@ -0,0 +1,99 @@
+// `Allans` is a map for calculating ADEV and AVAR, keyed by metric
+
+use allan::{Allan, Config, Style};
+use fnv::FnvHashMap;
+use std::hash::Hash;
+
+pub struct Allans<T> {
+    config: Config,
+    data: FnvHashMap<T, Allan>,
+}
+
+impl<T: Hash + Eq> Allans<T> {
+    pub fn new() -> Allans<T> {
+        let config = Allan::configure().max_tau(3600).style(Style::AllTau);
+        Allans {
+            config: config,
+            data: FnvHashMap::default(),
+        }
+    }
+
+    pub fn init(&mut self, key: T) {
+        self.data.insert(key, self.config.build().unwrap());
+    }
+
+    pub fn remove(&mut self, key: T) {
+        self.data.remove(&key);
+    }
+
+    pub fn record(&mut self, key: T, value: f64) {
+        if let Some(a) = self.data.get_mut(&key) {
+            a.record(value / 1_000_000_000.0); // convert to seconds
+            return;
+        }
+    }
+
+    pub fn adev(&mut self, key: T, tau: usize) -> Option<f64> {
+        if let Some(a) = self.data.get(&key) {
+            if let Some(t) = a.get(tau) {
+                if let Some(adev) = t.deviation() {
+                    return Some(adev);
+                }
+            }
+        }
+        None
+    }
+}
+
+#[cfg(feature = "benchmark")]
+#[cfg(test)]
+mod benchmark {
+    extern crate test;
+    use super::*;
+
+    #[bench]
+    fn init(b: &mut test::Bencher) {
+        b.iter(|| {
+            let mut allans = Allans::<String>::new();
+            allans.init("test".to_owned());
+        });
+    }
+
+    #[bench]
+    fn record(b: &mut test::Bencher) {
+        let mut allans = Allans::<String>::new();
+        allans.init("test".to_owned());
+        b.iter(|| { allans.record("test".to_owned(), 1.0); });
+    }
+}
+
+#[cfg(test)]
+mod test {
+    extern crate rand;
+
+    use self::rand::distributions::{IndependentSample, Range};
+    use super::*;
+
+    #[test]
+    fn white_noise() {
+        let mut allans = Allans::<String>::new();
+        let key = "test".to_owned();
+        allans.init(key.clone());
+
+        let mut rng = rand::thread_rng();
+        let between = Range::new(0.0, 1.0);
+        for _ in 0..10_000 {
+            let v = between.ind_sample(&mut rng);
+            allans.record(key.clone(), v);
+        }
+        for t in 1..1000 {
+            let v = allans.adev(key.clone(), t).unwrap_or_else(|| {
+                println!("error fetching for tau: {}", t);
+                panic!("error")
+            }) * t as f64;
+            if v <= 0.0000000004 || v >= 0.0000000006 {
+                panic!("tau: {} value: {} outside of range", t, v);
+            }
+        }
+    }
+}
diff --git a/tic/src/data/counters.rs b/tic/src/data/counters.rs
new file mode 100644
index 0000000..2084bf1
--- /dev/null
+++ b/tic/src/data/counters.rs
@@ -0,0 +1,76 @@
+// `Counters` is a map of u64 counters, keyed by metric
+
+use fnv::FnvHashMap;
+use std::hash::Hash;
+
+pub struct Counters<T> {
+    data: FnvHashMap<T, u64>,
+}
+
+impl<T: Hash + Eq> Counters<T> {
+    pub fn new() -> Counters<T> {
+        Counters { data: FnvHashMap::default() }
+    }
+
+    pub fn init(&mut self, key: T) {
+        self.data.insert(key, 0);
+    }
+
+    pub fn remove(&mut self, key: T) {
+        self.data.remove(&key);
+    }
+
+    #[allow(dead_code)]
+    pub fn increment(&mut self, key: T) {
+        self.increment_by(key, 1);
+    }
+
+    pub fn increment_by(&mut self, key: T, count: u64) {
+        if let Some(h) = self.data.get_mut(&key) {
+            *h += count;
+            return;
+        }
+    }
+
+    pub fn count(&mut self, key: T) -> u64 {
+        if let Some(h) = self.data.get(&key) {
+            *h
+        } else {
+            0
+        }
+    }
+}
+
+#[cfg(feature = "benchmark")]
+#[cfg(test)]
+mod benchmark {
+    extern crate test;
+    use super::*;
+
+    #[bench]
+    fn new(b: &mut test::Bencher) {
+        b.iter(|| Counters::<String>::new());
+    }
+
+    #[bench]
+    fn new_init(b: &mut test::Bencher) {
+        b.iter(|| {
+            let mut counters = Counters::<String>::new();
+            counters.init("test".to_owned());
+        });
+    }
+
+    #[bench]
+    fn increment(b: &mut test::Bencher) {
+        let mut counters = Counters::<String>::new();
+        counters.init("test".to_owned());
+        b.iter(|| { counters.increment("test".to_owned()); });
+    }
+
+    #[bench]
+    fn increment_by(b: &mut test::Bencher) {
+        let mut counters = Counters::<String>::new();
+        counters.init("test".to_owned());
+        b.iter(|| { counters.increment_by("test".to_owned(), 8); });
+    }
+}
diff --git a/tic/src/data/heatmaps.rs b/tic/src/data/heatmaps.rs
new file mode 100644
index 0000000..47141f3
--- /dev/null
+++ b/tic/src/data/heatmaps.rs
@@ -0,0 +1,95 @@
+// `Heatmaps` is a map of `Heatmap`s, keyed by metric
+
+extern crate heatmap;
+
+use fnv::FnvHashMap;
+use heatmap::Heatmap;
+use std::hash::Hash;
+use waterfall::Waterfall;
+
+pub struct Heatmaps<T> {
+    config: heatmap::Config,
+    pub data: FnvHashMap<T, Heatmap>,
+}
+
+impl<T: Hash + Eq> Heatmaps<T> {
+    pub fn new(slices: usize, t0: u64) -> Heatmaps<T> {
+        let config = Heatmap::configure()
+            .slice_duration(1_000_000_000)
+            .num_slices(slices)
+            .precision(2)
+            .start(t0);
+        Heatmaps {
+            config: config,
+            data: FnvHashMap::default(),
+        }
+    }
+
+    pub fn init(&mut self, key: T) {
+        self.data.insert(key, self.config.build().unwrap());
+    }
+
+    pub fn remove(&mut self, key: T) {
+        self.data.remove(&key);
+    }
+
+    pub fn increment(&mut self, key: T, start: u64, value: u64) {
+        self.increment_by(key, start, value, 1);
+    }
+
+    pub fn increment_by(&mut self, key: T, start: u64, value: u64, count: u64) {
+        if let Some(h) = self.data.get_mut(&key) {
+            let _ = h.increment_by(start, value, count);
+            return;
+        }
+    }
+
+    pub fn trace(&mut self, key: T, file: String) {
+        if let Some(h) = self.data.get_mut(&key) {
+            h.save(file);
+        }
+    }
+
+    pub fn waterfall(&self, key: T, file: String) {
+        if let Some(h) = self.data.get(&key) {
+            trace!("trace for heatmap with: {} slices", h.num_slices());
+            let mut waterfall = Waterfall::new();
+            waterfall.render_png(h, file);
+        }
+    }
+
+    pub fn clear(&mut self) {
+        for heatmap in self.data.values_mut() {
+            heatmap.clear();
+        }
+    }
+}
+
+#[cfg(feature = "benchmark")]
+#[cfg(test)]
+mod benchmark {
+    extern crate test;
+    use super::*;
+
+    #[bench]
+    fn init(b: &mut test::Bencher) {
+        b.iter(|| {
+            let mut heatmaps = Heatmaps::<String>::new(3600, 0);
+            heatmaps.init("test".to_owned());
+        });
+    }
+
+    #[bench]
+    fn increment(b: &mut test::Bencher) {
+        let mut heatmaps = Heatmaps::<String>::new(3600, 0);
+        heatmaps.init("test".to_owned());
+        b.iter(|| { heatmaps.increment("test".to_owned(), 1, 1); });
+    }
+
+    #[bench]
+    fn increment_large(b: &mut test::Bencher) {
+        let mut heatmaps = Heatmaps::<String>::new(3600, 0);
+        heatmaps.init("test".to_owned());
+        b.iter(|| { heatmaps.increment("test".to_owned(), 1, 8_675_309); });
+    }
+}
diff --git a/tic/src/data/histograms.rs b/tic/src/data/histograms.rs
new file mode 100644
index 0000000..d328e0e
--- /dev/null
+++ b/tic/src/data/histograms.rs
@@ -0,0 +1,169 @@
+// `Histograms` is a map of `Histogram`, keyed by metric
+
+extern crate histogram;
+
+use std::clone::Clone;
+use fnv::FnvHashMap;
+use histogram::Histogram;
+use std::hash::Hash;
+
+const ONE_SECOND: u64 = 1_000_000_000;
+const ONE_MINUTE: u64 = 60 * ONE_SECOND;
+
+pub struct Histograms<T> {
+    config: histogram::Config,
+    pub data: FnvHashMap<T, Histogram>,
+}
+
+impl<T: Hash + Eq + Clone> Default for Histograms<T> {
+    fn default() -> Histograms<T> {
+        Histograms {
+            config: Histogram::configure().max_value(ONE_MINUTE),
+            data: FnvHashMap::default(),
+        }
+    }
+}
+
+impl<T: Hash + Eq + Clone> Histograms<T> {
+    pub fn new() -> Histograms<T> {
+        Default::default()
+    }
+
+    pub fn new_from_config(config: histogram::Config) -> Histograms<T> {
+        Histograms {
+            config: config,
+            data: FnvHashMap::default(),
+        }
+    }
+
+    pub fn clone(&mut self) -> FnvHashMap<T, Histogram> {
+        self.data.clone()
+    }
+
+    pub fn increment(&mut self, key: T, duration: u64) {
+        self.increment_by(key, duration, 1);
+    }
+
+    pub fn increment_by(&mut self, key: T, duration: u64, count: u64) {
+        if let Some(h) = self.data.get_mut(&key) {
+            let _ = h.increment_by(duration, count);
+            return;
+        }
+    }
+
+    pub fn init(&mut self, key: T) {
+        self.data.insert(key, self.config.build().unwrap());
+    }
+
+    pub fn remove(&mut self, key: T) {
+        self.data.remove(&key);
+    }
+
+    pub fn clear(&mut self) {
+        for histogram in self.data.values_mut() {
+            histogram.clear();
+        }
+    }
+
+    pub fn percentile(&self, key: T, percentile: f64) -> Result<u64, &'static str> {
+        if let Some(h) = self.data.get(&key) {
+            return h.percentile(percentile);
+        }
+        Err("no data")
+    }
+}
+
+
+#[cfg(test)]
+mod tests {
+    use super::Histograms;
+
+    #[test]
+    fn test_new_0() {
+        let h = Histograms::<usize>::new();
+        assert_eq!(h.percentile(0, 50.0), Err("no data"));
+        assert_eq!(h.percentile(1, 50.0), Err("no data"));
+    }
+
+    #[test]
+    fn test_increment_0() {
+        let mut h = Histograms::<usize>::new();
+
+        h.init(1);
+        for i in 100..200 {
+            h.increment(1, i);
+        }
+
+        assert_eq!(h.percentile(1, 0.0).unwrap(), 100);
+        assert_eq!(h.percentile(1, 10.0).unwrap(), 109);
+        assert_eq!(h.percentile(1, 25.0).unwrap(), 124);
+        assert_eq!(h.percentile(1, 50.0).unwrap(), 150);
+        assert_eq!(h.percentile(1, 75.0).unwrap(), 175);
+        assert_eq!(h.percentile(1, 90.0).unwrap(), 190);
+        assert_eq!(h.percentile(1, 95.0).unwrap(), 195);
+        assert_eq!(h.percentile(1, 100.0).unwrap(), 199);
+
+        assert_eq!(h.percentile(0, 50.0), Err("no data"));
+    }
+}
+
+#[cfg(feature = "benchmark")]
+#[cfg(test)]
+mod benchmark {
+    extern crate test;
+    use super::*;
+
+    #[bench]
+    fn init(b: &mut test::Bencher) {
+        b.iter(|| {
+            let mut histograms = Histograms::<String>::new();
+            histograms.init("test".to_owned());
+        });
+    }
+
+    #[bench]
+    fn increment(b: &mut test::Bencher) {
+        let mut histograms = Histograms::<String>::new();
+        histograms.init("test".to_owned());
+        b.iter(|| { histograms.increment("test".to_owned(), 1); });
+    }
+
+    #[bench]
+    fn increment_large(b: &mut test::Bencher) {
+        let mut histograms = Histograms::<String>::new();
+        histograms.init("test".to_owned());
+        b.iter(|| { histograms.increment("test".to_owned(), 8_675_309); });
+    }
+}
+
+
+#[cfg(test)]
+mod test {
+    extern crate rand;
+
+    use self::rand::distributions::{IndependentSample, Range};
+    use super::*;
+
+    #[test]
+    fn white_noise() {
+        let mut h = Histograms::<String>::new();
+        let key = "test".to_owned();
+        h.init(key.clone());
+
+        let mut rng = rand::thread_rng();
+        let between = Range::new(1, 100);
+        for _ in 0..1_000_000 {
+            let v = between.ind_sample(&mut rng);
+            h.increment(key.clone(), v);
+        }
+        for t in vec![25.0, 50.0, 75.0, 90.0, 99.0, 99.9, 99.99] {
+            let v = h.percentile(key.clone(), t).unwrap_or_else(|_| {
+                println!("error percentile: {}", t);
+                panic!("error")
+            }) as f64;
+            if v <= t * 0.9 && v >= t * 1.1 {
+                panic!("percentile: {} value: {} outside of range", t, v);
+            }
+        }
+    }
+}
diff --git a/tic/src/data/meters.rs b/tic/src/data/meters.rs
new file mode 100644
index 0000000..fd7a01f
--- /dev/null
+++ b/tic/src/data/meters.rs
@@ -0,0 +1,71 @@
+// `Meters` hold calculated values
+
+use common::Percentile;
+use fnv::FnvHashMap;
+use std::fmt::Display;
+use std::hash::Hash;
+use std::marker::PhantomData;
+
+/// `Meters` are the aggregated result of stats which
+/// have been processed by the `Receiver`.
+#[derive(Clone)]
+pub struct Meters<T> {
+    resource_type: PhantomData<T>,
+    /// a map of labels to their u64 values
+    pub data: FnvHashMap<String, u64>,
+    /// a map of labels to their f64 values
+    pub data_float: FnvHashMap<String, f64>,
+}
+
+impl<T: Hash + Eq> Default for Meters<T> {
+    fn default() -> Meters<T> {
+        Meters {
+            data: FnvHashMap::default(),
+            data_float: FnvHashMap::default(),
+            resource_type: PhantomData::<T>,
+        }
+    }
+}
+
+impl<T: Hash + Eq + Send + Display + Clone> Meters<T> {
+    /// create a new empty set of `Meters`
+    pub fn new() -> Meters<T> {
+        Default::default()
+    }
+
+    /// update the count of events for a given metric
+    pub fn set_count(&mut self, channel: T, value: u64) {
+        let key = format!("{}_count", channel);
+        self.data.insert(key, value);
+    }
+
+    /// update the `Percentile` for a given metric
+    pub fn set_percentile(&mut self, channel: T, percentile: Percentile, value: u64) {
+        let key = format!("{}_{}_nanoseconds", channel, percentile.0);
+        self.data.insert(key, value);
+    }
+
+    /// update the Allan Deviation for a given metric at a specific Tau
+    pub fn set_adev(&mut self, channel: T, tau: usize, value: f64) {
+        let key = format!("{}_tau_{}_adev", channel, tau);
+        self.data_float.insert(key, value);
+    }
+
+    /// gets the count for a given metric
+    pub fn count(&self, channel: &T) -> Option<&u64> {
+        let key = format!("{}_count", channel);
+        self.data.get(&key)
+    }
+
+    /// get the `Percentile` for a given metric
+    pub fn percentile(&self, channel: &T, percentile: Percentile) -> Option<&u64> {
+        let key = format!("{}_{}_nanoseconds", channel, percentile.0);
+        self.data.get(&key)
+    }
+
+    /// get the Allan Deviation for the channel for a given Tau
+    pub fn adev(&self, channel: T, tau: usize) -> Option<&f64> {
+        let key = format!("{}_tau_{}_adev", channel, tau);
+        self.data_float.get(&key)
+    }
+}
diff --git a/tic/src/data/mod.rs b/tic/src/data/mod.rs
new file mode 100644
index 0000000..d8907a3
--- /dev/null
+++ b/tic/src/data/mod.rs
@@ -0,0 +1,13 @@
+mod allans;
+mod counters;
+mod heatmaps;
+mod histograms;
+mod meters;
+mod sample;
+
+pub use self::allans::Allans;
+pub use self::counters::Counters;
+pub use self::heatmaps::Heatmaps;
+pub use self::histograms::Histograms;
+pub use self::meters::Meters;
+pub use self::sample::Sample;
diff --git a/tic/src/data/sample.rs b/tic/src/data/sample.rs
new file mode 100644
index 0000000..10dae48
--- /dev/null
+++ b/tic/src/data/sample.rs
@@ -0,0 +1,63 @@
+use std::fmt::Display;
+use std::hash::Hash;
+
+/// a start and stop time for an event
+#[derive(Clone)]
+pub struct Sample<T> {
+    start: u64,
+    stop: u64,
+    count: u64,
+    channel: T,
+}
+
+impl<T: Hash + Eq + Send + Display + Clone> Sample<T> {
+    /// Create a new Sample for a single event
+    pub fn new(start: u64, stop: u64, channel: T) -> Sample<T> {
+        Sample {
+            start: start,
+            stop: stop,
+            count: 1,
+            channel: channel,
+        }
+    }
+
+    /// Create a new Sample when multiple occurances of the event have happened
+    pub fn counted(start: u64, stop: u64, count: u64, channel: T) -> Sample<T> {
+        Sample {
+            start: start,
+            stop: stop,
+            count: count,
+            channel: channel,
+        }
+    }
+
+    /// return the metric /// deprecated
+    pub fn metric(&self) -> T {
+        self.channel.clone()
+    }
+
+    /// return the metric
+    pub fn channel(&self) -> T {
+        self.channel.clone()
+    }
+
+    /// return the duration
+    pub fn duration(&self) -> u64 {
+        self.stop - self.start
+    }
+
+    /// return the start time
+    pub fn start(&self) -> u64 {
+        self.start
+    }
+
+    /// return the stop time
+    pub fn stop(&self) -> u64 {
+        self.stop
+    }
+
+    /// return the count of events
+    pub fn count(&self) -> u64 {
+        self.count
+    }
+}
diff --git a/tic/src/lib.rs b/tic/src/lib.rs
new file mode 100644
index 0000000..acaac54
--- /dev/null
+++ b/tic/src/lib.rs
@@ -0,0 +1,109 @@
+//! a high-performance stats library focused on rates and latencies from timestamped events
+//!
+//! # Features
+//!
+//! * high throughput - millions of samples per second
+//! * latched histogram - for analyzing the full distribution of sample lengths
+//! * heatmaps - to generate distribution traces and waterfalls
+//! * meters - to expose readings for client usage
+//! * http metrics - simple metrics on http for scraping and monitoring, Prometheus compatible
+//! * generic - channel type is generic, and used to label the type of sample
+//! * flexible - per channel stats are accessible by registering appropriate `Interest`s
+//!
+//! # Usage
+//!
+//! This crate is on [crates.io](https://crates.io/crates/tic) and can be used by adding
+//! `tic` to your `Cargo.toml`
+//!
+//! ```toml
+//! [dependencies]
+//! tic = "*"
+//! ```
+//!
+//! and to your crate root
+//!
+//! ```rust
+//! extern crate tic;
+//! ```
+//!
+//! # Example: Service Mode
+//!
+//! This example shows how to use `tic` in a long-running service
+//!
+//! ```rust
+//! use std::fmt;
+//! use std::thread;
+//! use std::time;
+//! use tic::{Interest, Receiver, Sample};
+//!
+//! // define an enum of stats labels
+//! #[derive(Clone, PartialEq, Eq, Hash)]
+//! pub enum Metric {
+//!     Ok,
+//! }
+//!
+//! // implement the fmt::Display trait
+//! impl fmt::Display for Metric {
+//!    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+//!        match *self {
+//!            Metric::Ok => write!(f, "ok"),
+//!        }
+//!    }
+//! }
+//!
+//! // configure a receiver
+//! let mut receiver = Receiver::configure()
+//!         .service(true)
+//!         .http_listen("localhost:42024".to_owned())
+//!         .build();
+//!
+//! // register some interests
+//! receiver.add_interest(Interest::Count(Metric::Ok));
+//! receiver.add_interest(Interest::Percentile(Metric::Ok));
+//!
+//! // get a sender and a clocksource
+//! let mut sender = receiver.get_sender();
+//! let clocksource = receiver.get_clocksource();
+//!
+//! // run the receiver in a separate thread
+//! thread::spawn(move || { receiver.run(); });
+//!
+//! // put your application logic here, and increment stats
+//! for _ in 0..100 {
+//!     let start = clocksource.counter();
+//! 	// do some work that takes some time
+//!     let stop = clocksource.counter();
+//!		sender.send(Sample::new(start, stop, Metric::Ok));
+//! }
+//!
+//! // stats will be available on the http_listen port while main() is running
+#![cfg_attr(feature = "cargo-clippy", deny(missing_docs))]
+#![cfg_attr(feature = "cargo-clippy", deny(warnings))]
+#![cfg_attr(feature = "benchmark", feature(test))]
+#[cfg(feature = "benchmark")]
+extern crate test;
+
+extern crate allan;
+extern crate clocksource;
+extern crate fnv;
+extern crate heatmap;
+extern crate histogram;
+#[macro_use]
+extern crate log;
+extern crate mio;
+extern crate mpmc;
+extern crate tiny_http;
+extern crate waterfall;
+
+mod common;
+mod config;
+mod data;
+mod receiver;
+mod sender;
+
+pub use clocksource::Clocksource;
+pub use common::{Interest, Percentile};
+pub use config::Config;
+pub use data::{Meters, Sample};
+pub use receiver::Receiver;
+pub use sender::Sender;
diff --git a/tic/src/receiver.rs b/tic/src/receiver.rs
new file mode 100644
index 0000000..efa6bac
--- /dev/null
+++ b/tic/src/receiver.rs
@@ -0,0 +1,430 @@
+#![allow(deprecated)]
+
+use clocksource::Clocksource;
+use common::{self, ControlMessage, Interest, Percentile};
+use config::Config;
+use data::{Allans, Counters, Heatmaps, Histograms, Meters, Sample};
+use mio::{Events, Poll, PollOpt, Ready, Token, channel};
+use mpmc::Queue;
+use sender::Sender;
+use std::collections::HashSet;
+use std::fmt::Display;
+use std::hash::Hash;
+use std::net::ToSocketAddrs;
+use std::sync::Arc;
+use tiny_http::{Request, Response, Server};
+use fnv::FnvHashMap;
+use histogram::Histogram;
+use std::borrow::Borrow;
+
+// define token numbers for data and control queues
+const TOKEN_DATA: usize = 1;
+const TOKEN_CONTROL: usize = 2;
+
+/// a `Receiver` processes incoming `Sample`s and generates stats
+pub struct Receiver<T> {
+    window_time: u64,
+    window_duration: u64,
+    end_time: u64,
+    run_duration: u64,
+    config: Config<T>,
+    empty_queue: Arc<Queue<Vec<Sample<T>>>>,
+    data_rx: channel::Receiver<Vec<Sample<T>>>,
+    data_tx: channel::SyncSender<Vec<Sample<T>>>,
+    control_rx: channel::Receiver<ControlMessage<T>>,
+    control_tx: channel::SyncSender<ControlMessage<T>>,
+    allans: Allans<T>,
+    counters: Counters<T>,
+    histograms: Histograms<T>,
+    histogram_rx: channel::Receiver<FnvHashMap<T, Histogram>>,
+    histogram_tx: channel::SyncSender<FnvHashMap<T, Histogram>>,
+    meters: Meters<T>,
+    interests: HashSet<Interest<T>>,
+    taus: Vec<usize>,
+    percentiles: Vec<Percentile>,
+    heatmaps: Heatmaps<T>,
+    server: Option<Server>,
+    clocksource: Clocksource,
+    poll: Poll,
+}
+
+impl<T: Hash + Eq + Send + Clone + Display> Default for Receiver<T> {
+    /// create a default `Receiver`
+    fn default() -> Self {
+        Config::new().build()
+    }
+}
+
+impl<T: Hash + Eq + Send + Display + Clone> Receiver<T> {
+    /// create a new `Receiver` using the defaults
+    pub fn new() -> Receiver<T> {
+        Default::default()
+    }
+
+    /// create a `Receiver` from a tic::Config
+    pub fn configured(config: Config<T>) -> Receiver<T> {
+        let (data_tx, data_rx) = channel::sync_channel::<Vec<Sample<T>>>(config.capacity);
+        let (control_tx, control_rx) = channel::sync_channel::<ControlMessage<T>>(config.capacity);
+        let (histogram_tx, histogram_rx) = channel::sync_channel::<FnvHashMap<T, Histogram>>(1);
+        let empty_queue = Arc::new(Queue::with_capacity(config.capacity));
+        for _ in 0..config.capacity {
+            let _ = empty_queue.push(Vec::with_capacity(config.batch_size));
+        }
+
+        let slices = config.duration * config.windows;
+
+        let listen = config.http_listen.clone();
+        let server = start_listener(&listen);
+
+        let clocksource = Clocksource::default();
+
+        // calculate counter values for start, window, and end times
+        let start_time = clocksource.counter();
+        let window_duration = (config.duration as f64 * clocksource.frequency()) as u64;
+        let window_time = start_time + window_duration;
+        let run_duration = config.windows as u64 * window_duration;
+        let end_time = start_time + run_duration;
+        let histograms = Histograms::new_from_config(config.histogram_config);
+
+        let poll = Poll::new().unwrap();
+        poll.register(
+            &data_rx,
+            Token(TOKEN_DATA),
+            Ready::readable(),
+            PollOpt::level(),
+        ).unwrap();
+        poll.register(
+            &control_rx,
+            Token(TOKEN_CONTROL),
+            Ready::readable(),
+            PollOpt::level(),
+        ).unwrap();
+
+        Receiver {
+            window_duration: window_duration,
+            window_time: window_time,
+            run_duration: run_duration,
+            end_time: end_time,
+            config: config,
+            empty_queue: empty_queue,
+            data_tx: data_tx,
+            data_rx: data_rx,
+            control_tx: control_tx,
+            control_rx: control_rx,
+            allans: Allans::new(),
+            counters: Counters::new(),
+            histograms: histograms,
+            histogram_rx: histogram_rx,
+            histogram_tx: histogram_tx,
+            meters: Meters::new(),
+            interests: HashSet::new(),
+            taus: common::default_taus(),
+            percentiles: common::default_percentiles(),
+            heatmaps: Heatmaps::new(slices, start_time),
+            server: server,
+            clocksource: clocksource,
+            poll: poll,
+        }
+    }
+
+    /// Create a new Config which can be used to build() a Receiver
+    pub fn configure() -> Config<T> {
+        Config::default()
+    }
+
+    pub fn get_reciver_histogram(&self) -> &channel::Receiver<FnvHashMap<T, Histogram>> {
+        self.histogram_rx.borrow()
+    }
+
+    /// returns a clone of the `Sender`
+    pub fn get_sender(&self) -> Sender<T> {
+        Sender::new(
+            self.empty_queue.clone(),
+            self.data_tx.clone(),
+            self.control_tx.clone(),
+            self.config.batch_size,
+        )
+    }
+
+    /// returns a clone of the `Clocksource`
+    pub fn get_clocksource(&self) -> Clocksource {
+        self.clocksource.clone()
+    }
+
+    /// register a stat for export
+    pub fn add_interest(&mut self, interest: Interest<T>) {
+        match interest.clone() {
+            Interest::AllanDeviation(key) => {
+                self.allans.init(key);
+            }
+            Interest::Count(key) => {
+                self.counters.init(key);
+            }
+            Interest::Percentile(key) => {
+                self.histograms.init(key);
+            }
+            Interest::Trace(key, _) |
+            Interest::Waterfall(key, _) => {
+                self.heatmaps.init(key);
+            }
+        }
+        self.interests.insert(interest);
+    }
+
+    /// de-register a stat for export
+    pub fn remove_interest(&mut self, interest: &Interest<T>) {
+        match interest.clone() {
+            Interest::AllanDeviation(key) => {
+                self.allans.remove(key);
+            }
+            Interest::Count(key) => {
+                self.counters.remove(key);
+            }
+            Interest::Percentile(key) => {
+                self.histograms.remove(key);
+            }
+            Interest::Trace(key, _) |
+            Interest::Waterfall(key, _) => {
+                self.heatmaps.remove(key);
+            }
+        }
+        self.interests.remove(interest);
+    }
+
+    /// clear the heatmaps
+    pub fn clear_heatmaps(&mut self) {
+        self.heatmaps.clear();
+    }
+
+    /// run the receive loop for one window
+    pub fn run_once(&mut self) {
+        trace!("run once");
+
+        let window_time = self.window_time;
+        let mut http_time = self.clocksource.counter() +
+            (0.1 * self.clocksource.frequency()) as u64;
+
+        loop {
+            if self.clocksource.counter() > http_time {
+                self.try_handle_http(&self.server);
+                http_time += (0.1 * self.clocksource.frequency()) as u64;
+            }
+
+            if self.check_elapsed(window_time) {
+                return;
+            }
+
+            let mut events = Events::with_capacity(1024);
+            self.poll.poll(&mut events, self.config.poll_delay).unwrap();
+            for event in events.iter() {
+                trace!("got: {} events", events.len());
+                match event.token().0 {
+                    TOKEN_DATA => {
+                        if let Ok(mut results) = self.data_rx.try_recv() {
+                            for result in &results {
+                                let t0 = self.clocksource.convert(result.start());
+                                let t1 = self.clocksource.convert(result.stop());
+                                let dt = t1 - t0;
+                                self.allans.record(result.metric(), dt);
+                                self.counters.increment_by(result.metric(), result.count());
+                                self.histograms.increment(result.metric(), dt as u64);
+                                self.heatmaps.increment(
+                                    result.metric(),
+                                    t0 as u64,
+                                    dt as u64,
+                                );
+                            }
+                            results.clear();
+                            let _ = self.empty_queue.push(results);
+                            trace!("finished processing");
+                        }
+                    }
+                    TOKEN_CONTROL => {
+                        if let Ok(msg) = self.control_rx.try_recv() {
+                            match msg {
+                                ControlMessage::AddInterest(interest) => {
+                                    self.add_interest(interest);
+                                }
+                                ControlMessage::RemoveInterest(interest) => {
+                                    self.remove_interest(&interest);
+                                }
+                            }
+                        }
+                    }
+                    _ => {}
+                }
+            }
+            trace!("run complete");
+        }
+    }
+
+    // this function will check if the window is passed
+    // if it has, it will refresh the `Meters`
+    fn check_elapsed(&mut self, t1: u64) -> bool {
+        let tsc = self.clocksource.counter();
+        if tsc >= t1 {
+            for interest in &self.interests {
+                match *interest {
+                    Interest::Count(ref key) => {
+                        self.meters.set_count(
+                            key.clone(),
+                            self.counters.count(key.clone()),
+                        );
+                    }
+                    Interest::Percentile(ref key) => {
+                        for percentile in self.percentiles.clone() {
+                            self.meters.set_percentile(
+                                key.clone(),
+                                percentile.clone(),
+                                self.histograms
+                                    .percentile(key.clone(), percentile.1)
+                                    .unwrap_or(0),
+                            );
+                        }
+                    }
+                    Interest::AllanDeviation(ref key) => {
+                        for tau in self.taus.clone() {
+                            if let Some(adev) = self.allans.adev(key.clone(), tau) {
+                                self.meters.set_adev(key.clone(), tau, adev);
+                            }
+                        }
+                    }
+                    Interest::Trace(_, _) |
+                    Interest::Waterfall(_, _) => {}
+                }
+            }
+
+            self.histogram_tx.try_send(self.histograms.clone());
+            self.histograms.clear();
+            self.window_time += self.window_duration;
+            return true;
+        }
+        false
+    }
+
+    /// run the receive loop for all windows, output waterfall and traces as requested
+    pub fn run(&mut self) {
+        let mut window = 0;
+        debug!("collection ready");
+        'outer: loop {
+            'inner: loop {
+                self.run_once();
+                window += 1;
+                if window >= self.config.windows {
+                    break 'inner;
+                }
+            }
+
+            self.save_files();
+
+            if !self.config.service_mode {
+                break 'outer;
+            } else {
+                self.heatmaps.clear();
+                self.end_time += self.run_duration;
+            }
+        }
+    }
+
+    /// save all artifacts
+    pub fn save_files(&mut self) {
+        for interest in self.interests.clone() {
+            match interest {
+                Interest::Trace(l, f) => {
+                    self.heatmaps.trace(l, f);
+                }
+                Interest::Waterfall(l, f) => {
+                    self.heatmaps.waterfall(l, f);
+                }
+                _ => {}
+            }
+        }
+    }
+
+    /// return a clone of the raw `Meters`
+    pub fn clone_meters(&self) -> Meters<T> {
+        self.meters.clone()
+    }
+
+    // try to handle a http request
+    fn try_handle_http(&self, server: &Option<Server>) {
+        if let Some(ref s) = *server {
+            if let Ok(Some(request)) = s.try_recv() {
+                trace!("handle http request");
+                self.handle_http(request);
+            }
+        }
+    }
+
+    // actually handle the http request
+    fn handle_http(&self, request: Request) {
+        let mut output = "".to_owned();
+
+        match request.url() {
+            "/vars" | "/metrics" => {
+                for (stat, value) in &self.meters.data {
+                    output = output + &format!("{} {}\n", stat, value);
+                }
+                for (stat, value) in &self.meters.data_float {
+                    output = output + &format!("{} {}\n", stat, value);
+                }
+            }
+            _ => {
+                output += "{";
+                for (stat, value) in &self.meters.data {
+                    output = output + &format!("\"{}\":{},", stat, value);
+                }
+                for (stat, value) in &self.meters.data_float {
+                    output = output + &format!("\"{}\":{},", stat, value);
+                }
+                output.pop();
+                output += "}";
+            }
+        }
+
+        let response = Response::from_string(output);
+        let _ = request.respond(response);
+    }
+}
+
+// start the HTTP listener for tic
+fn start_listener(listen: &Option<String>) -> Option<Server> {
+    if let Some(ref l) = *listen {
+        let http_socket = l.to_socket_addrs().unwrap().next().unwrap();
+
+        debug!("starting HTTP listener");
+        return Some(Server::http(http_socket).unwrap());
+    }
+    None
+}
+
+#[cfg(feature = "benchmark")]
+#[cfg(test)]
+mod benchmark {
+    extern crate test;
+    use super::*;
+
+    #[bench]
+    fn heavy_cycle(b: &mut test::Bencher) {
+        let mut receiver = Receiver::<String>::new();
+        receiver.add_interest(Interest::Count("test".to_owned()));
+        receiver.add_interest(Interest::Percentile("test".to_owned()));
+        receiver.add_interest(Interest::AllanDeviation("test".to_owned()));
+        b.iter(|| {
+            // full stats evaluation
+            receiver.check_elapsed(0);
+        });
+    }
+
+    #[bench]
+    fn cheap_cycle(b: &mut test::Bencher) {
+        let mut receiver = Receiver::<String>::new();
+        receiver.add_interest(Interest::Count("test".to_owned()));
+        receiver.add_interest(Interest::Percentile("test".to_owned()));
+        receiver.add_interest(Interest::AllanDeviation("test".to_owned()));
+        b.iter(|| {
+            // no stats evaluation just get clock and compare
+            receiver.check_elapsed(u64::max_value());
+        });
+    }
+}
diff --git a/tic/src/sender.rs b/tic/src/sender.rs
new file mode 100644
index 0000000..06ffeb2
--- /dev/null
+++ b/tic/src/sender.rs
@@ -0,0 +1,105 @@
+#![allow(deprecated)]
+
+use common::{ControlMessage, Interest};
+use data::Sample;
+use mio::channel;
+use mio::channel::TrySendError;
+use mpmc::Queue;
+use std::hash::Hash;
+use std::io;
+use std::sync::Arc;
+
+#[derive(Clone)]
+/// a Sender is used to push `Sample`s to the `Receiver` it is clonable for sharing between threads
+pub struct Sender<T> {
+    batch_size: usize,
+    buffer: Option<Vec<Sample<T>>>,
+    control_tx: channel::SyncSender<ControlMessage<T>>,
+    data_tx: channel::SyncSender<Vec<Sample<T>>>,
+    rx_queue: Arc<Queue<Vec<Sample<T>>>>,
+}
+
+impl<T: Hash + Eq + Send + Clone> Sender<T> {
+    /// create a new `Sender` for use in client threads
+    pub fn new(
+        rx_queue: Arc<Queue<Vec<Sample<T>>>>,
+        data_tx: channel::SyncSender<Vec<Sample<T>>>,
+        control_tx: channel::SyncSender<ControlMessage<T>>,
+        batch_size: usize,
+    ) -> Sender<T> {
+        let buffer = Vec::with_capacity(batch_size);
+        Sender {
+            batch_size: batch_size,
+            buffer: Some(buffer),
+            data_tx: data_tx,
+            control_tx: control_tx,
+            rx_queue: rx_queue,
+        }
+    }
+
+    #[inline]
+    /// a function to send a `Sample` to the `Receiver`
+    pub fn send(&mut self, sample: Sample<T>) -> Result<(), io::Error> {
+        let mut buffer = self.buffer.take().unwrap();
+        buffer.push(sample);
+        if buffer.len() >= self.batch_size {
+            match self.data_tx.try_send(buffer) {
+                Ok(_) => {
+                    // try to re-use a buffer, otherwise allocate new
+                    if let Some(b) = self.rx_queue.pop() {
+                        self.buffer = Some(b);
+                    } else {
+                        self.buffer = Some(Vec::with_capacity(self.batch_size));
+                    }
+                    Ok(())
+                }
+                Err(e) => {
+                    match e {
+                        TrySendError::Io(e) => {
+                            error!("io error: {}", e);
+                            Err(e)
+                        }
+                        TrySendError::Full(buffer) |
+                        TrySendError::Disconnected(buffer) => {
+                            self.buffer = Some(buffer);
+                            Ok(())
+                        }
+                    }
+                }
+            }
+        } else {
+            self.buffer = Some(buffer);
+            Ok(())
+        }
+    }
+
+    /// register an `Interest`
+    pub fn add_interest(&mut self, interest: Interest<T>) {
+        let _ = self.control_tx.send(ControlMessage::AddInterest(interest));
+    }
+
+    /// de-register an `Interest`
+    pub fn remove_interest(&mut self, interest: Interest<T>) {
+        let _ = self.control_tx.send(
+            ControlMessage::RemoveInterest(interest),
+        );
+    }
+
+    /// a function to change the batch size of the `Sender`
+    pub fn set_batch_size(&mut self, batch_size: usize) {
+        self.batch_size = batch_size;
+    }
+
+    #[inline]
+    /// mock try_send `Sample` to the `Receiver`
+    pub fn try_send(&mut self, sample: Sample<T>) -> Result<(), (Sample<T>)> {
+        let mut buffer = self.buffer.take().unwrap();
+        if buffer.len() < self.batch_size - 1 {
+            buffer.push(sample);
+            self.buffer = Some(buffer);
+            Ok(())
+        } else {
+            Err(sample)
+        }
+    }
+}
